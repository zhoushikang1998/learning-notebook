## JavaNIO

### 0 I/O：概念性描述

#### 为什么要使用 NIO？

- NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。
- NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。

#### 流与块的比较

- 原来的 I/O 库(在 `java.io.*`中) 与 NIO 最重要的区别是数据打包和传输的方式。原来的 **I/O 以流的方式处理数据**，而 **NIO 以块的方式处理数据**。
- *面向流* 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是**相对简单的**。不利的一面是，面向流的 I/O 通常相当慢。
- 一个 *面向块* 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要**快得多**。但是面向块的 I/O **缺少一些面向流的 I/O 所具有的优雅性和简单性。**

####  编程方式

- **NIO 是面向缓存区，或者面向 块 编程的。**

### 1 通道（Channel）和缓冲区（Buffer）

- `通道 `和 `缓冲区 `是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。
- 通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。
- **一个 Buffer 实质上是一个容器对象。**发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。

#### 什么是缓冲区？

- `Buffer` 是一个对象， 它包含一些要写入或者刚读出的数据。 
- 在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，都是将它放到缓冲区中。
- 缓冲区**实质上是一个数组**。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 *仅仅* 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。

#### 缓冲区类型

- 最常用的缓冲区类型是 `ByteBuffer`。一个 `ByteBuffer` 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。
- 对于每一种基本 Java 类型都有一种缓冲区类型。每一个 `Buffer` 类都是 `Buffer` 接口的一个实例。 除了 `ByteBuffer`，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。
- 因为大多数标准 I/O 操作都使用 **`ByteBuffer`，所以它具有所有共享的缓冲区操作以及一些特有的操作。**

#### 什么是通道？

- `Channel`是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。
- 所有数据都通过 `Buffer` 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。

#### 通道类型

- 通道与流的不同之处在于**通道是双向的**。而流只是在一个方向上移动(一个流必须是 `InputStream` 或者 `OutputStream` 的子类)， 而 `通道 `可以用于读、写或者同时用于读写。
- 因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。

### 2 NIO 中的读和写

- 读和写是 I/O 的基本过程。**从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中**。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。

#### 从文件中读取

- 读取文件涉及三个步骤：(1) 从 `FileInputStream` 获取 `Channel`，(2) 创建 `Buffer`，(3) 将数据从 `Channel` 读到 `Buffer `中。
- 写入文件同上：

### 3 缓冲区内部细节

- 两个重要的缓冲区组件：状态变量和访问方法 (accessor)。
  - 状态变量：内部统计机制的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。
  - 访问方法：在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，**还需要查看数据**。这是使用 *访问方法* `get()` 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 `put()`。

#### 状态变量

- 可以用三个值指定缓冲区在任意时刻的状态：
  - position
    - `position` 变量跟踪已经写了多少数据。它指定了下一个字节将放到数组的哪一个元素中。
  - limit
    - `limit` 变量表明**还有多少数据**需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。
    - `position` 总是小于或者等于 `limit`。
  - capacity
    - 缓冲区的 `capacity` 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。
    - position <= limit <= capacity
- 改变状态变量的方法
  - 读取、写入---------> 只改变 position
  - flip（将数据写到输出通道中）
    1. 将 `limit` 设置为当前 `position`。
    2. 将 `position` 设置为 0。
  - clear（重设缓冲区以便接收更多的字节）
    1. 将 `limit` 设置为与 `capacity` 相同。
    2. 设置 `position` 为 0。

#### 访问方法

- get 方法

  ```java
  byte get();	// 获取单个字节
  ByteBuffer get( byte dst[] );	// 将一组字节读到一个数组中
  ByteBuffer get( byte dst[], int offset, int length );	// 将一组字节读到一个数组中
  byte get( int index );	// 缓冲区中的特定位置获取字节
  ```

- put 方法

  ```java
  ByteBuffer put( byte b );	//  写入（put） 单个字节
  ByteBuffer put( byte src[] );	// 写入来自一个数组的一组字节
  ByteBuffer put( byte src[], int offset, int length ); 	// 写入来自一个数组的一组字节
  ByteBuffer put( ByteBuffer src );	// 将数据从一个给定的源 ByteBuffer 写入这个 ByteBuffer。
  ByteBuffer put( int index, byte b );	// 将字节写入缓冲区中特定的 位置
  ```

  

- 相对的和绝对的

  - *相对* 意味着 `get()` 操作服从 `limit` 和 `position` 值 ― 更明确地说，字节是从当前 `position` 读取的，而 `position` 在 `get` 之后会增加。
  - 一个 *绝对* 方法会忽略 `limit` 和 `position` 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。

### 4 深入缓冲区

- 使用缓冲区的一些更复杂的方面，比如缓冲区分配、包装和分片。



#### 缓冲区分配与包装

- 在能够读和写之前，必须有一个缓冲区。要创建缓冲区，您必须 *分配* 它。我们使用静态方法 `allocate()` 来分配缓冲区：
  - `allocate()` 方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中
  - 还可以通过 `wrap()` 方法将一个现有的数组转换为缓冲区

#### 缓冲区分片

- `slice()` 方法根据现有的缓冲区创建一种 *子缓冲区* 。也就是说，它**创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。**
- 在某种意义上，子缓冲区就像原来的缓冲区中的一个 *窗口* 。窗口的起始和结束位置通过设置 `position` 和 `limit` 值来指定，然后调用 `Buffer` 的 `slice()` 方法：
- `片 `是缓冲区的 `子缓冲区 `。不过， `片段 `和 `缓冲区 `共享同一个底层数据数组。

#### 缓冲区分片与数据共享

- 缓冲区片对于促进抽象非常有帮助。可以编写自己的函数处理整个缓冲区，而且如果想要将这个过程应用于子缓冲区上，您只需取主缓冲区的一个片，并将它传递给您的函数。这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易。

#### 只读缓冲区

- 只读缓冲区 ― 可以读取它们，但是不能向它们写入。可以**通过调用缓冲区的 `asReadOnlyBuffer()` 方法，**将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。
- **只读缓冲区对于保护数据很有用。**在将缓冲区传递给某个对象的方法时，您无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以 *保证* 该缓冲区不会被修改。
- **不能将只读的缓冲区转换为可写的缓冲区。**

#### 直接和间接缓冲区

- 另一种有用的 `ByteBuffer` 是直接缓冲区。 *直接缓冲区* 是为加快 I/O 速度，而以一种特殊的方式分配其内存的缓冲区。
- ***给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。***
- 还可以用内存映射文件创建直接缓冲区。

#### 内存映射文件 I/O

- 内存映射文件 I/O 是一种**读和写文件数据的方法**，它可以比常规的基于流或者基于通道的 I/O 快得多。
- 现代操作系统一般**根据需要将文件的部分映射为内存的部分**，从而实现文件系统。Java 内存映射机制不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。
- 尽管创建内存映射文件相当简单，但是**向它写入可能是危险的**。仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。



### 5 分散和聚集

- 分散/聚集 I/O 是使用多个而不是单个缓冲区来保存数据的读写方法。
- 一个**分散的读取**就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中。同样地，一个**聚集写入**是向缓冲区数组而不是向单个缓冲区写入数据。
- 分散/聚集 I/O 对于将数据流划分为单独的部分很有用，这**有助于实现复杂的数据格式。**



#### 分散/聚集 I/O

- 通道可以有选择地实现两个新的接口： `ScatteringByteChannel` 和 `GatheringByteChannel`。一个 `ScatteringByteChannel` 是一个具有两个附加读方法的通道：

  ```java
  // 这些 long read() 方法很像标准的 read 方法，只不过它们不是取单个缓冲区而是取一个缓冲区数组。
  long read( ByteBuffer[] dsts );
  long read( ByteBuffer[] dsts, int offset, int length );
  ```

- 在 *分散读取* 中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个。在某种意义上，**缓冲区数组就像一个大缓冲区。**

#### 分散/聚集的应用

- 分散/聚集 I/O 对于将**数据划分为几个部分很有用。**例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。
- 我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以**分散读取会自动找到有空间接受数据的第一个缓冲区**。在这个缓冲区填满后，它就会移动到下一个缓冲区。

#### 聚集写入

- *聚集写入* 类似于分散读取，只不过是用来写入。它也有接受缓冲区数组的方法：

  ```java
  long write( ByteBuffer[] srcs );
  long write( ByteBuffer[] srcs, int offset, int length );
  ```

- 聚集写对于**把一组单独的缓冲区中组成单个数据流很有用。**可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。



### 6 文件锁定

- 文件锁就像常规的 Java 对象锁 ― 它们是 *劝告式的（advisory）* 锁。它们不阻止任何形式的数据访问，相反，它们**通过锁的共享和获取赖允许系统的不同部分相互协调**。
- **可以锁定整个文件或者文件的一部分。**如果您获取一个排它锁，那么其他人就不能获得同一个文件或者文件的一部分上的锁。如果您获得一个共享锁，那么其他人可以获得同一个文件或者文件一部分上的共享锁，但是不能获得排它锁。文件锁定并不总是出于保护数据的目的。例如，您可能临时锁定一个文件以保证特定的写操作成为原子的，而不会有其他程序的干扰。

#### 锁定文件

- 要获取文件的一部分上的锁，您要调用一个打开的 `FileChannel` 上的 `lock()` 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。

  ```java
  // 获取锁
  fc.lock( start, end, false );
  // 释放锁
  lock.release();
  ```

  

#### 文件锁定和可移植性

- 文件锁定可能是一个复杂的操作，特别是考虑到不同的操作系统是以不同的方式实现锁这一事实。下面的指导原则将尽可能保持代码的可移植性：
  - 只使用排它锁。
  - 将所有的锁视为劝告式的（advisory）。

### 7 连网和异步 I/O

- **连网是学习异步 I/O 的很好基础**，而异步 I/O 对于在 Java 语言中执行任何输入/输出过程的人来说，无疑都是必须具备的知识。NIO 中的连网与 NIO 中的其他任何操作没有什么不同 ― **它依赖通道和缓冲区**，而您通常使用 `InputStream` 和 `OutputStream` 来获得通道。

#### 异步 I/O

- **异步 I/O 是一种 *没有阻塞地* 读写数据的方法。**通常，在代码进行 `read()` 调用时，代码会阻塞直至有可供读取的数据。同样， `write()` 调用将会阻塞直至数据能够写入。
- 异步 I/O 的一个优势在于，它**允许同时根据大量的输入和输出执行 I/O**。同步程序常常要求助于轮询，或者创建许许多多的线程以处理大量的连接。使用异步 I/O，**可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程。**

#### Selectors

- 异步 I/O 中的核心对象名为 `Selector`。`Selector` 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。

- 特点说明
  - Netty 的 IO 线程 NioEventLoop 聚合了 Selector（选择器，也叫多路复用器），可以同时并发处理成百上千个客户的连接。
  - 当线程从某客户端 Socket 通道进行读写数据时，若没有数据可写，该线程可以进行其他任务。
  - 线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。
  - 由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 操作导致的线程挂起。
  - 一个 IO 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到极大地提升 。

##### SelectionKey

-  `SelectionKey` 代表这个通道在此 `Selector` 上的这个注册。当某个 `Selector` 通知您某个传入事件时，它是通过提供对应于该事件的 `SelectionKey` 来进行的。`SelectionKey` 还可以用于取消通道的注册。

##### 内部循环

- 使用 `Selectors` 的几乎每个程序都像下面这样使用内部循环：

  ```java
  // 这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， select() 方法将返回所发生的事件的数量。
  int num = selector.select();
  
  // 接下来，我们调用 Selector 的 selectedKeys() 方法，它返回发生了事件的 SelectionKey 对象的一个 集合 。
  Set selectedKeys = selector.selectedKeys();
  // 我们通过迭代 SelectionKeys 并依次处理每个 SelectionKey 来处理事件。对于每一个 SelectionKey，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。
  Iterator it = selectedKeys.iterator();
   
  while (it.hasNext()) {
       SelectionKey key = (SelectionKey)it.next();
       // ... deal with I/O event ...
  }
  ```


#### Selectors、Channel 和 Buffer 的关系

- 每个 channel 对应一个 Buffer
- Selector 对应一个线程，一个线程对应多个 channel
- 程序切换到哪个 channel 是由事件决定的，**Event** 就是一个重要的概念
- Selector 会根据不同的事件，在各个通道上切换
- Buffer 就是一个内存块，底层有一个数组
- 数据的读取写入是通过 Buffer，这个和 BIO 不同，BIO 中是输入流或输出流，不能双向，但是 NIO 的 Buffer 可以读也可以写，需要 flip 切换
- channel 是双向的，可以返回底层操作系统的情况，比如 Linux，底层的操作系统通道就是双向的。 



### 8 NIO 与零拷贝

- 零拷贝时网络编程的关键，很多性能优化都离不开。
- Java 中常用的零拷贝：mmap（内存映射）、sendFile





## Netty

- Netty 是一个广泛使用的 Java 网络编程框架

- Netty 的优势

  - 并发高
  - 传输快
    - 依赖了NIO的一个特性——***零拷贝***。
  - 封装好

- NIO 的单线程能处理连接的数量比 BIO 要高出很多，而为什么单线程能处理更多的连接呢？

  - 当一个连接建立之后，他有两个步骤要做，第一步是**接收完客户端发过来的全部数据**，第二步是服务端处理完请求业务之后返回response给客户端。NIO和 BIO 的区别主要是在第一步。

  - NIO 中，当一个 Socket 建立好之后，Thread 并不会阻塞去接受这个 Socket，而是将这个请求交给 Selector，Selector 会不断的去遍历所有的 Socket，一旦有一个 Socket 建立完成，他会通知 Thread，然后 Thread 处理完数据再返回给客户端——**这个过程是不阻塞的**，这样就能让一个 Thread 处理更多的请求了。

    ![](images/NIO的处理流程.webp)

