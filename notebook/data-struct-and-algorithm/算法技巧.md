## 双指针方法

### 同向双指针（快慢指针）

- 将两个指针分别定义为`快指针（fast）`和`慢指针（slow）`，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。

### 异向双指针（对撞指针）

- **对撞指针**是指在有序数组中，将指向最左侧的索引定义为`左指针(left)`，最右侧的定义为`右指针(right)`，然后从两头向中间进行数组遍历。

  >  对撞数组适用于**有序数组**，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题。

## 滑动窗口（双指针的特例）

- 用以解决数组/字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。

  - 找到符合题意的移动方式
  - 找到更新结果的方式

- 大体框架

  ```bash
  def findSubArray(nums):
      N = len(nums) # 数组/字符串长度
      left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
      sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
      res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
      while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
          sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
          while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
              sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
              left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
          # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
          res = max(res, right - left + 1) # 需要更新结果
          right += 1 # 移动右指针，去探索新的区间
      return res
  ```

  

## 快慢指针方法



## Top K 模式（堆）