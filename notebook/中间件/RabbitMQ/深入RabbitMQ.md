## 一、AMQP 

- AMQP把客户端和代理服务器之间的通信数据拆分成一种叫作帧（frame）的块结构



### AMQP 作为一种 RPC 传输机制

- 一个AMQP连接可以有多个信道，允许客户端和服务器之间进行多次会话。从技术上讲，这被称为**多路复用（multiplexing）**，对于执行多个任务的多线程或异步应用程序来说，它非常有用。
- 在创建客户端应用程序时，不要使用过多的信道使事情变得复杂。

### AMQP RPC帧结构

- AMQP 使用类和方法在客户端和服务器之间创建公共语言，这些类和方法被称为 **AMQP 命令（AMQP commands）**。

#### AMQP帧组件

- 当使用命令与 RabbitMQ 进行交互时，**执行这些命令所需的所有参数被封装在一个称为帧的数据结构中**，帧对数据进行编码以便传输。帧为命令及其参数提供了一种有效的方式，用于在网络上进行编码和分隔。
- 低层AMQP帧由五个不同的组件组成：
  1. 帧头
     1. 帧类型（五种）
     2. 信道编号
     3. 以字节为单位的帧大小
  2. 帧有效载荷
  3. 结束字节标记（ASCII值206）
- 注意
  - AMQP 中的**心跳行为**用于确保客户端和服务器之间相互响应，这是展示 AMQP 作为一种**双向 RPC 协议**的完美示例。可以通过更改 rabbitmq.config 文件中的 heartbat 值来更改 RabbitMQ 的最大心跳间隔
- 五种帧类型
  - **协议头帧**：用于连接到 RabbitMQ，仅使用一次。（对开发者是透明的）
  - **方法帧**：携带发送给 RabbitMQ 或从 RabbitMQ 接收到的 RPC 请求或响应。（可见的）
  - **内容头帧**：包含一条消息的大小和属性。（可见的）
  - **消息体帧**：包含消息的内容。（可见的）
  - **心跳帧**：在客户端与RabbitMQ之间进行传递，作为一种校验机制确保连接的两端都可用且在正常工作。（对开发者是透明的）

#### 将消息编组成帧（方法帧==》内容头帧==》消息体帧）

- 使用方法帧、内容头帧和消息体帧向 RabbitMQ 发布消息。
- 发送的第一个帧是携带命令和执行它所需参数（如交换器和路由键）的方法帧。方法帧之后是内容帧，包含内容头和消息体。内容头帧包含消息属性以及消息体大小。
- **AMQP 的帧大小有一个上限，如果消息体超过这个上限，消息内容将被拆分成多个消息体帧。**
- 当向 RabbitMQ 发送消息时，**在方法（Method）帧中会发送一个 Basic.Publish 命令**，随后是一个带有消息属性的**内容头（ContentHeader）帧**，该内容头帧包括消息的内容类型和发送时间等。这些属性被封装在AMQP规范中所定义的 **Basic.Properties** 数据结构中。最后，消息内容被编组到一定数量的**消息体帧**中。
- 方法帧和内容头帧：二进制打包数据。消息体帧：任何数据。

#### 方法帧、内容头帧、消息体帧

- 方法帧结构
  - 方法帧携带着构建RPC请求所需的类、方法以及相关参数。
  - Basic.Publish 方法帧由五个组件组成：**用于标识 Basic.Publish RPC 请求的类和方法类型、交换器名称、路由键值和mandatory标志**。
  - 方法帧有效载荷中的**每个数据值都是按照数据类型采用特定的格式进行编码**。这种编码格式旨在最大限度地减少网络传输中的字节大小，提供数据完整性，并确保数据编组和解组速度尽可能快。实际的格式根据数据类型的不同而不同，但通常表现为一个字节后跟数字数据，或者是一个字节后跟一个字节大小的字段，其后则是文本数据。
- 内容头帧
  - 在方法帧之后发送的消息头除了告知 RabbitMQ 该**消息的大小**之外，消息头帧还包含**消息的各种属性**，为 RabbitMQ 服务器和可能接收它的任何应用程序提供了对消息的描述。这些**属性存储在 Basic.Properties 映射表**中，可能包含描述消息内容的数据，也可能是完全空白。大多数客户端库将预先填充一小部分字段，比如内容类型和投递模式。
- 消息体帧
  - 消息的消息体帧与正在传输的数据类型无关，并且可能包含二进制或文本数据。消息体帧都是消息中包含实际消息数据的结构。
  - 消息属性和消息体组合在一起构成了数据的强大封装格式。将消息的描述性属性与内容无关的消息体结合起来，确保你可以使用RabbitMQ来处理你认为合适的任何类型的数据。

### 使用协议

#### 声明交换器

- 使用 **Exchange.Declare** 命令可以创建交换器，该命令提供了定义交换器名称和类型的参数，以及用于消息处理的其他元数据。
- 一旦命令被发送，RabbitMQ 在创建了交换器之后将发送一个 **Exchange.DeclareOk 方法帧**作为响应。
- 如果出于某种原因**命令执行失败**，则 RabbitMQ 将使用 Channel.Close 命令关闭发送 Channel.Declare 命令的信道。该响应将包含一个数字回复编码和文本值，用于说明 Exchange.Declare 失败并关闭信道的原因。

#### 声明队列

- 一旦交换器创建成功，就可以通过发送 Queue.Declare 命令让 RabbitMQ 创建一个队列。
- 如果 Queue.Declare 命令执行失败，信道将被关闭。
- 在声明一个队列时，**多次发送同一个 Queue.Declare 命令并不会有任何副作用**。RabbitMQ 不会处理后续的队列声明，只会返回队列相关的有用信息，比如队列中待处理消息的数量以及订阅该队列的消费者数量。
- **优雅地处理错误**
  - 要正确处理错误，你的**客户端应用程序应该监听来自 RabbitMQ 的 Channel.Close 命令**以便能够正确响应。
  - 风格
    - 异常风格
    - 回调风格

#### 绑定队列到交换器

- 将队列绑定到交换器的 Queue.Bind 命令**每次只能指定一个队列**。在发出 Queue.Bind 命令后，如果处理成功，那么你的应用程序会收到一个 Queue.BindOk 方法帧。
- 客户端成功发出Queue.Bind命令之后通过一个路由键将队列绑定到交换器，客户端将收到一个 Queue.BindOk 方法帧作为响应。
- **作为RabbitMQ服务器和客户端之间的RPC交互基本示例，Exchange.Declare、Queue.Declare 和 Queue.Bind 命令展示了 AMQP 规范中所有同步命令类似的通用模式。**

#### 发布消息到RabbitMQ

- 当发布消息到 RabbitMQ 时，多个帧封装了发送到服务器的消息数据。在实际的消息内容到达 RabbitMQ 之前，客户端应用程序发送一个 **Basic.Publish 方法帧、一个内容头帧和至少一个消息体帧**。
- 当 RabbitMQ 接收到一个消息的所有帧并确定下一步操作之前，它将**检查方法帧以获取它所需要的信息**。Basic.Publish 方法**帧携带消息的交换器名称和路由键**。在评估这些数据时，RabbitMQ 会尝试将 Basic.Publish 帧中的交换器名称与配置交换器的数据库进行匹配。
- 要想确保你的消息成功投递，请在发布时**将 mandatory 标志设置为true，或者使用投递确认机制。**（都可能会对应用程序的消息发布速度产生负面影响。）
- 当 RabbitMQ 发现某一个交换器与 **Basic.Properties 方法帧**中的交换器名称相匹配时，它将判断该交换器中的绑定信息，并通过路由键寻找匹配的队列。
  - RabbitMQ 服务器将以 FIFO 的顺序将消息放入队列中。放入队列数据结构中的并不是实际消息，而是**消息的引用**。
  - 当RabbitMQ 准备投递消息时，它将使用这个引用来编组消息并通过网络进行发送。这为发布到多个队列的消息提供了实质性的优化。当把消息发送到多个目标时，只保存消息的一个实例会占用较少的物理内存。
- 只要没有消费者正在监听队列，**消息就会被存储在队列中**。当添加更多消息时，队列的大小也会随之增加。RabbitMQ 可以将这些消息保存在内存中或写入磁盘，**具体取决于消息 Basic.Properties 中指定的delivery-mode属性。**

#### 从RabbitMQ中消费消息

- 要消费 RabbitMQ 队列中的消息，消费者应用程序通过发出 **Basic.Consume 命令**来订阅 RabbitMQ 中的队列。**服务器将使用 Basic.ConsumeOk 进行响应**，让客户端知道它将打开闸门并释放一大堆消息，或者至少是一两条消息。
- 消费者将开始通过我们已经熟悉的一种格式接收消息，这种格式包括对应的 B**asic.Deliver 方法和它们的内容头以及消息体帧**。
- **停止接收消息**：一旦发送完 Basic.Consume 命令，消费者将处于**活跃状态**，直到某些事件中的其中一个被触发。如果消费者想要停止接收消息，则可以发出一个 **Basic.Cancel 命令**。值得注意的是，这个命令是**异步发出**的，而 RabbitMQ 可能仍然在发送消息，所以消费者在接收到一个 Basic.CancelOk 响应帧之前仍然可以接收到 RabbitMQ 预分配给它的任意数量的消息。
- 参数设置：
  - Basic.Consume 命令中的 **no_ack 参数**。当设置该参数为 true 时，RabbitMQ 将连续发送消息直到消费者发送一个 Basic.Cancel 命令或消费者断开连接为止。如果 no_ack 标志被设置为 false，则消费者必须通过**发送 Basic.Ack RPC请求**来确认收到的每条消息。
  - 当发送 Basic.Ack 响应帧时，消费者必须在 Basic.Deliver 方法帧中**传递一个名为投递标签（delivery tag）的参数**。**RabbitMQ 使用投递标签和信道作为唯一标识符来实现消息确认、拒绝和否定确认。**



## 二、消息属性（Basic.Properties）详解

- 各个基本属性：
  - 使用 **content-type** 属性让消费者知道如何解释消息体。
  - 使用 **content-encoding** 属性来指示消息体使用某种特殊的方式进行压缩或编码。
  - 填充 **message-id** 和 **correlation-id** 来唯一标识消息和消息响应，用于在工作流程中实现消息跟踪。
  - 利用 **timestamp** 属性减少消息大小，并创建一个规范定义来描述消息创建时间。
  - 使用 **expiration** 属性表明消息过期。
  - 告诉 RabbitMQ 使用 **delivery-mode**将消息写入磁盘或内存队列。
  - 使用 **app-id** 和 **user-id** 来帮助追踪出现问题的消息发布者应用程序。
  - 使用 **type ** 属性来定义发布者和消费者之间的契约。
  - 使用 **reply-to** 属性实现响应消息的路由。
  - 使用 **headers** 映射表定义自由格式的属性和实现 RabbitMQ 路由。
- 避免使用 **priority** 属性，**cluster-id** 属性背后发生的事情以及为什么不能使用它。

### 使用content-type属性创建显式的消息契约

- content-type传输**消息体的MIME类型**。
- 关于**自描述消息和消息内容**的思考：
  - 使用标准的序列化格式如 JSON、Msgpack 或 XML 是明智的。
  - 这些格式允许使用任何编程语言编写任意数量的消费者应用程序。因为数据是以这些格式自我描述的，所以编写潜在的消费者应用程序会很容易，并且在核心应用程序之外的网络环境上对消息解码也会变得更加容易。
- 通过 content-type 属性**指定序列化格式**，可以更好地支持适应未来的消费者应用程序。



### 通过 gzip 和 content-encoding 属性压缩消息大小

- 默认情况下，**通过 AMQP 发送的消息并不会被压缩**。在处理如 XML 这种过于繁杂的标记语言时，甚至在消息数量较大的场景下处理像 JSON 或 YAML 等较少使用标记的轻量级格式时，这都可能会是个问题。
- 最好不要更改生产环境中已发布和已消费消息的契约，从而最大限度地减少对现有代码的潜在影响。但是，**如果消息大小影响整体性能和稳定性**，那么使用 content-encoding 消息头将允许消费者对消息进行预判断，确保它们可以解码消息体中发送的任何格式。
- **AMQP 规范规定 content-encoding 用于存储 MIME 内容编码。**（不正确方式：设置成 UTF-8）
- 可以使用 content-encoding 属性在**收到消息时自动解码消息**。通过在调用消费者代码之前进行预处理、反序列化和解压缩消息，可以简化消费者应用程序中的逻辑和代码。你的消费者代码将能够专注于那些处理消息体的任务。
- 结合 content-type 属性后，content-encoding 属性使消费者应用程序能够**基于一种明确的契约与发布者进行交互。**



### 使用 message-id 和 correlation-id 引用消息（应用级别使用）

- **Message-id**：当消息流经松耦合系统中的各个组件时，message-id 属性使得消息能够在消息头中携带数据，该数据可以唯一地识别该消息。
- **Correlation-id**：
  - 指定该消息是另一个消息的响应，通过携带关联消息的 message-id 可以做到这一点。
  - 另一种选择是使用它来传送关联消息的事务ID或其他类似数据。

### 创建时间：timestamp属性（应用级别使用）

- timestamp 属性在试图诊断经由 RabbitMQ 消息流中发生的任何意外行为时非常有用。通过使用 timestam p属性来指示消息的创建时间，**消费者可以评估消息投递过程的性能。**
- 携带一个 UNIX 纪元时间值（Epoch Value）来指定消息的创建时间。
- 通过判断消息属性中的 timestamp，消费者应用程序可以决定是否处理消息、丢弃消息，甚至向监控应用程序发布警报消息，以便让其他人知道消息的生存时间已经超过预期值。
- **时间戳没有时区上下文，因此建议在所有消息中使用 UTC 或其他统一的时区。**

### 消息自动过期 expiration

- 如果消息没有被消费，expiration 属性告诉 RabbitMQ 何时应该丢弃消息。
- 要在 RabbitMQ 中使用 expiration 属性，请将字符串值设置为一个 UNIX 纪元时间戳，用于指定消息的最大存活时间。然后把它存储为字符串。
- 使用 expiration 属性时，如果把一个已经过期的消息发布到服务器，则该消息不会被路由到任何队列，而是直接被丢弃。
- **TTL**
  - RabbitMQ 还有可以让消息过期的其他功能，这些功能只在某些场景下才会生效。在**声明一个队列时**，你可以将一个 x-message-ttl 参数和队列定义一起进行传递。这个值也应该是一个 UNIX 纪元时间戳，但是它使用毫秒精度（值×1000）来表示一个整数值。该值告诉队列在指定时间过后自动丢弃消息。

### 使用 delivery-mode 平衡速度和安全性

- delivery-mode 属性是一个字节字段，向消息代理服务器表明在将消息投递给任何正在等待的消费者之前，你希望先将它持久化到磁盘上。
- delivery-mode 属性有两个可能的值：**1表示非持久化消息，2表示持久化消息。**
- 消息持久化通常可能会与队列中的持久性（durable）设置相混淆。
  - 队列的持久性属性告诉 RabbitMQ 队列的定义在重新启动 RabbitMQ 服务器或群集之后是否仍然有效。
  - 只有消息的 delivery-mode 才会向 RabbitMQ 指定消息是否应该被持久化。一个队列可能包含持久化和未持久化的消息。
- 由于内存 IO 本身比磁盘 IO 快，因此将 delivery-mode 指定为 1 将会尽可能降低消息投递的延迟性。

### 使用 app-id 和 user-id 验证消息来源

- 这两个属性也可以携带一些信息以便消费者应用程序在处理消息之前进行验证。（**标识消息源**）
- **app-id**：
  - 作为发布者和消费者之间加强契约的方法，在处理消息之前检查 app-id **允许应用程序丢弃那些来源不明或不受支持的消息**。
  - **收集统计数据**。通过提供 app-id 属性，收集统计信息的消费者不必对消息体进行反序列化或解码。
  - 当试图**追踪队列中的恶意消息**时，加强使用 app-id 可以更容易地追踪恶意消息的来源。
- **user-id**：
  - 使用 user-id 属性来标识已登录的用户

### 使用 type 属性获取明细

- type 属性定义为“消息类型名称”，表示它用于应用程序并且没有规定正式的行为。**应用程序可以使用它来确定如何处理一个消息。**
- 当自描述性的序列化格式不够快时：
  - 选择 Thrift 或 Protobuf 这样的 序列化格式，但与 JSON 不同，这些二进制编码的消息格式不是自描述的，需**要依赖外部定义文件来进行序列化和反序列化**。这种外部的依赖性和缺乏自描述性能够使网络传输上的有效载荷更小，但对其自身而言也是一种折衷方案。
  - type 属性可用于指定记录类型或外部定义文件，如果无法正确访问处理消息所需的 .thrift 或 .proto 文件，消费者就能够拒绝这些消息。
- ETL （extract-transform-load，ETL）处理是一种标准实践，通过它提取 OLTP 数据并最终将其加载到数据仓库以满足报表需求。
  - ETL队列消费者处理多种类型的消息，并使用type属性来决定将提取的数据存储在哪个系统、表或集群中。

### 使用 reply-to 属性实现动态工作流

- **使用 reply-to 可以构建一个用来回复消息的私有响应队列。**
- reply-to属性没有正式的定义，但可以携带一个可用于回复消息的路由键或队列名。
- **谨慎使用**。

### 使用消息头自定义属性（headers）

- headers 属性是一个**键/值对表**，允许用户自定义任意的键和值。键可以是 ASCII 或 Unicode 字符串，最大长度为 255 个字符。而值可以是任何有效的 AMQP  值类型。
- headers 属性允许你添加任何你想要添加的数据到消息头表中。
- 它还具有另一个独特的功能：**RabbitMQ 可以根据 headers 表中填充的值路由消息，而不需要依赖于路由键。**

### 优先级属性（priority）

- RabbitMQ 已按照 AMQP 规范实现了 priority 字段。它的可能值被定义为一个介于 0 到 9 之间的整数，**用于指定队列中的消息优先级。**按照规范，如果首先发布一条优先级为 9 的消息，随后再发布一条优先级为 0 的消息，**则新连接的消费者将在优先级为 9 的消息之前接收到优先级为 0 的消息**。



## 三、消息发布的性能权衡

### 平衡投递速度与可靠投递

- 金发姑娘原则。
- 使用 **mandatory 设置**，RabbitMQ 将不接受不可路由消息。
  - mandatory 标志是一个与 Basic.Publish RPC 命令一起传递的参数，告诉 RabbitMQ 如果消息不可路由，它应该通过 **Basic.Return RPC 命令**将消息返回给发布者。
  - 要发布带有 mandatory 标志的消息，只需**在交换器、路由键、消息以及消息属性参数之后传入该标志**。
- **发布者确认机制作为事务的轻量级替代方法**
  - 当发布者发布给所有队列的已路由消息被消费者应用程序直接消费时，或者消息被放入队列并根据需要进行持久化时，一个 **Basic.Ack 请求**会被发送到发布者。
  - 如果消息无法路由，代理服务器将发送一个 **Basic.Nack RPC 请求**用于表示失败。然后由发布者决定该如何处理该信息。
- 备用交换器：处理无法路由的消息
  - **死信队列**
  - **备用交换器在第一次声明交换器时被指定，用来提供一种预先存在的交换器，即如果交换器无法路由消息，那么消息就会被路由到这个新的备用交换器。**
  - mandatory 标志
    - 如果在将消息发送到具有备用交换器的交换器上时设置了 mandatory 标志，那么**一旦预期的交换器无法正常路由消息，Basic.Return 就不会发给发布者。**
    - 当 mandatory 标志为 true 时，向备用交换器发送不可路由消息的行为满足消息已经被发布这一条件。
    - RabbitMQ 的消息路由模式与其他交换器一样适用于备用交换器，认识到这一点也很重要。
    - 如果一个队列没有使用它的初始路由键进行绑定以接收消息，那么该消息将不会被放入队列，并且将会丢失。
  - 要使用备用交换器，你必须首先创建用来接收不可路由消息的交换器。然后，在设置接收消息的主交换器时，将 **alternate-exchange 参数**添加到Exchange.Declare命令中。
- 基于事务的批量处理
  - AMQP 事务（也就是TX）类提供了一种机制，通过这种机制，消息可以批量发布到 RabbitMQ，然后提交到队列或回滚。
  - 原子事务
    - 如果不止一个队列受到事务中任何命令的影响，则提交就不具备原子性。
    - 当将 delivery-mode 值设置为 2 从而对消息进行持久化时，真正的原子事务可能会导致发布者的性能问题。
- 使用 **HA 队列**避免节点故障
  - HA 队列是 RabbitMQ 团队创建的一项增强功能（未包含在AMQP规范中），它**允许队列在多个服务器上拥有冗余副本。**
  - HA 队列需要 **RabbitMQ 集群环境**，可以通过以下两种方式之一进行设置：使用 AMQ 或使用基于 Web 的管理界面。
  - 当发布消息到设置为高可用的队列中时，该消息会被发送到集群中的每台服务器，该集群管理着 HA 队列。**一旦消息在集群中的任何节点都完成消费，那么消息的所有副本将立即从其他节点中删除。**
  - HA 队列可以跨越集群中的每台服务器，或者仅使用一批独立节点。要指定一批独立节点，不是将 **x-ha-policy 参数**设置为 all，而是将 x-ha-policy 设置为 nodes，然后再传入另一个参数 x-ha-nodes，该参数包含一个应该配置队列的节点列表。
  - HA 队列有一个**主服务器节点**，其他所有节点都是辅助节点。如果主节点发生故障，其中一个辅助节点将接管主节点的角色。
- 通过设置 **delivery-mode 为 2** 将消息持久化到磁盘
  - 如果将 delivery-mode 设置为 2，RabbitMQ 将确保消息存储到磁盘。这通常被称为消息持久化（message persistence），将消息存储到磁盘可确保如果 RabbitMQ 代理服务器因任何原因进行重启之后，消息仍然在队列中。
  - 除了将 delivery-mode 设置为 2，你的队列在创建时必须声明为持久性（durable）。
  - 当 RabbitMQ 持久化消息时，可能会有相当大的写入偏差
    - 在高吞吐量的消息通信环境中，RabbitMQ 将持久化消息写入磁盘，并通过引用追踪它们直到它们不存在于任何队列中为止。一旦消息的所有引用消失，RabbitMQ 将从磁盘中删除消息。
    - 在进行高速写入时，经常会发生由于**硬件配置不足而导致的性能问题**，因为在大多数情况下，磁盘的写缓存要比读缓存小得多。在大多数操作系统中，内核将使用空余 RAM 来缓冲从磁盘读取的页面，而将缓存写入磁盘的组件只有磁盘控制器和磁盘。
    - 正因为如此，在使用持久化消息时**正确评估硬件需求**非常重要。一个容量不足的服务器执行大量写入操作可能导致整个 RabbitMQ 服务器性能急剧下降。
  - 为了正确配置 RabbitMQ 服务器中用于持久化消息的硬件，可以应用与 OLTP 数据库相同的规则。
- 

###  RabbitMQ 回推

- 使用一种被称为 **TCP 背压（Backpressure）的机制**来解决这个问题。RabbitMQ 不会礼貌地要求发布者停止发送消息，而是停止接受 TCP 套接字上的低层数据。
- 在内部，**RabbitMQ 使用信用的概念来管理回推发布者的时机**。在建立新的连接时，连接将被分配一个预定数量的可用信用值。然后，当 RabbitMQ 接收每个 RPC 命令时，将扣除一个点的信用值。一旦 RPC 请求在内部完成处理，连接就会返还被扣除的信用值。连接的信用值余额由 RabbitMQ 评估，以确定它是否应该从连接的套接字读取数据。如果一个连接的信用值不足，它将被跳过直到它有足够的信用值为止。
- RabbitMQ 团队扩展了 AMQP 规范，添加了**在达到连接信用阈值时发送通知的机制**，用于通知客户端其连接已被阻塞。**Connection.Blocked 和 Connection.Unblocked** 是可以随时发送的异步方法，以便在 RabbitMQ 对客户端进行阻塞或取消阻塞时通知到客户端。
- 使用管理 API 管理连接状态
  - 管理 API 提供 RESTful URL 端点用于查询连接、信道、队列以及 RabbitMQ 中任何其他向外暴露对象的状态。
  - 在管理 API 中，阻塞状态适用于连接中的信道，而不是连接本身。查询信道状态时可以获取多个字段，包括 name、node、connection_details、consumer_count 和 client_flow_blocked 等。其中 client_flow_blocked 标志指示 RabbitMQ 是否将 TCP 背压应用于连接。


## 四、消费消息，避免拉取

### 对比 Basic.Get 和 Basic.Consume

- RabbitMQ 实现了两个不同的 AMQP RPC 命令来获取队列中的消息：Basic.Get 和 Basic.Consume
- Basic.Get 是一个轮询模型，而 Basic.Consume 是一个推送模型。

 #### Basic.Get

- 当应用程序使用 Basic.Get 请求来获取消息时，每次它想要接收消息就必须**发送一个新的请求**，即使队列中存在多个消息。
  - 当发出一个 Basic.Get，如果你想要获取消息的队列中有一条消息正处于等待处理状态，RabbitMQ 就会回应一个 **Basic.GetOk RPC 响应**。
  - 如果队列中没有待处理的消息，它将回复 **Basic.GetEmpty**，表示队列中没有消息。
- 避免使用的原因：
  - **性能：**使用 Basic.Get 会导致每条消息都会产生与 RabbitMQ 同步通信的开销，这一过程由发送请求帧的客户端应用程序和发送应答的 RabbitMQ 组成。
  - **影响吞吐量**：避免使用 Basic.Get 的一个潜在的不太明显的原因是它会影响吞吐量，由于 Basic.Get 的临时性，RabbitMQ 不能以任何方式优化投递过程，因为它永远不知道应用程序何时会请求消息。

#### Basic.Consume

- **发布—订阅模式**
  - 通过使用 Basic.Consume RPC 命令来消费消息，可以使用 RabbitMQ 注册应用程序，并告诉它在消费者可用时以异步方式向消费者发送消息。这通常被称为**发布—订阅模式**（publish-subscribe pattern，或pub-sub）。
  - 与使用 Basic.Get 时与 RabbitMQ 创建的同步会话不同，使用 Basic.Consume 消费消息意味着**应用程序会在消息可用时自动从RabbitMQ接收消息**，直到客户端发出Basic.Cancel为止。
  - **Consume.OK**：应用程序仍然需要确认消息以便 让RabbitMQ 知道消息已经被处理。
- 消费者标签
  - 当应用程序发出 Basic.Consume 时会创建一个唯一的字符串，用来**标识通过已建立的信道与 RabbitMQ 进行通信的应用程序**。这个字符串被称为**消费者标签（Consumer Tag）**，RabbitMQ 每次都会把该字符串与消息一起发送给应用程序。
  - 通过发送一个 Basic.Cancel RPC 命令，消费者标签可以用来取消从 RabbitMQ 获取消息。
  - 如果应用程序需要对从不同队列接收到的消息执行不同的操作，则可以使用 Basic.Consume 请求中的消费者标签来确定如何处理消息。



### 优化消费者性能

- 当发布消息时，对消息的消费在**吞吐量与可靠投递**之间存在一种平衡。

#### 使用 no-ack 模式实现更快的吞吐量

- 消费消息时，应用程序将自己注册到 RabbitMQ，并要求消息在可用时进行投递。你的应用程序发送一个 Basic.Consume RPC 请求，与该请求一起发送的还有一个 **no-ack 标志**。当这个标志被启用时，它会告诉 RabbitMQ 你的**消费者在接收到消息时不会进行确认**，RabbitMQ 只管尽快发送它们。
- 使用 no_ack = True 消费消息是让 RabbitMQ 将消息投递给消费者的最快方式，但这也是发送消息最不可靠的方式。（**最快最不可靠**）
- 使用 no-ack 模式，如果有可用消息，RabbitMQ 将会持续向消费者发送它们直到**套接字缓冲区被填满为止**。
- **在Linux中增加接收套接字缓冲区**
  - 增加 net.core.rmem_default 和 net.core.rmem_max 值

#### 通过服务质量（QoS）设置控制消费者预取

- AMQP 规范要求信道具有服务质量（Quality Of Service，QoS）设置，即**在确认消息接收之前，消费者可以预先要求接收一定数量的消息**。QoS 设置允许 RabbitMQ 通过为消费者预先分配一定数量的消息来实现更高效地消息发送。
- 与被禁用确认（no_ack=True）的消费者不同，如果消费者应用程序**在确认消息之前崩溃，则在套接字关闭时，所有预取的消息将返回到队列**。
- 虽然 AMQP 规范要求 Basic.QoS 方法同时设置预取总量和预取大小，但如果**设置了 no-ack 选项，预取大小将被忽略**。
- **将预取值调整到最佳水平**
- **一次确认多个消息**
  - 使用 QoS 设置的好处之一就是不需要用 Basic.Ack RPC 响应来确认收到的每条消息。相反，Basic.Ack RPC 响应具有一个名为 **multiple 的属性**，当把它设置为 True 时就能让 RabbitMQ 知道应用程序**想要确认所有以前未确认的消息。**
  - 同时确认多个消息可以使处理消息所需的**网络通信量最小化**，从而提高消息吞吐量。
  - **这种确认带有某种程度的风险**。如果成功地处理了一些消息，并且应用程序在确认它们之前就已经死亡，则所有未确认的消息将返回队列以供其他消费者进行处理。

####  消费者使用事务

- 事务处理允许消费者应用程序提交和回滚批量操作。
- 事务不适用于已禁用确认的消费者。



### 拒绝消息

- 当消息本身或消息的处理过程出现问题时，RabbitMQ 提供了**两种将消息踢回代理服务器的机制**：
  - Basic.Reject
  - Basic.Nack

#### Basic.Reject

- Basic.Reject 是一个 AMQP 指定的 RPC 响应，用于通知代理服务器无法对所投递的消息进行处理。
- 当消费者拒绝消息时，可以**指示 RabbitMQ 丢弃消息或使用 requeue 标志重新发送消息**。当启用 requeue 标志时，RabbitMQ 将把消息放回到队列中并再次处理。
- 可以使用 Basic.Ack 一次性确认接收或处理多个消息，但**不能使用 Basic.Reject 同时拒绝多个消息**——要达到这个效果就需要使用 Basic.Nack。

#### Basic.Nack

- AMQP 不提供，RabbitMQ 专有的扩展，其他 AMQP 代理服务器等不支持该扩展。
- Basic.Nack 方法实现与 Basic.Reject 响应方法相同的行为，但添加了所缺的多消息参数来对 Basic.Ack 多消息处理行为进行补充。

### 死信交换器

- RabbitMQ 的**死信交换器（Dead-Letter eXchange，DLX）功能是对 AMQP 规范的扩展**，是一种可以拒绝已投递消息的可选行为。在尝试诊断为何消费特定消息会出现问题时，这个功能非常有用。
- 在 RabbitMQ 中，死信交换器是一种正常的交换器。创建它时没有特别的要求也不需要执行特别的操作。使交换器成为死信交换器的唯一要做的事情是**在创建队列时声明该交换器将被用作保存被拒绝的消息**。一旦拒绝了一个不重新发送的消息，RabbitMQ 将把消息路由到队列的 x-dead-letter-exchange 参数中指定的交换器。
- **注意：**死信交换器与备用交换器不同。**过期或被拒绝的消息**通过死信交换器进行投递，而备用交换器则路由那些**无法由 RabbitMQ 路由的信息**。
- 声明队列时指定死信交换器：
  - 创建 Queue 对象时将交换器名称作为 dead_letter_exchange 参数进行传入。
  - 在发出 Queue.Declare RPC 请求时作为 x-dead-letter-exchange 参数进行传入。
  - 自定义参数允许指定与队列定义一起存储的任意键/值对。
- 死信功能还允许**使用预先指定的值覆盖路由键**。这样可以允许使用**同一个交换器同时处理死信消息和非死信消息**，但需要确保死信消息不被投递到相同的队列。设置预定义的路由键需要在声明队列时指定一个额外的参数 x-dead-letter-routing-key。



### 控制队列

- 定义队列时，有多个设置可以**确定队列的行为**。队列至少可以做到以下几点：
  - 自动删除自己。
  - 只允许一个消费者进行消费。
  - 自动过期消息。
  - 保持有限数量的消息。
  - 将旧消息推出堆栈。
- 按照 AMQP 规范，**队列的设置是不可变的**，意识到这点很重要。一旦你声明了一个队列，你就不能改变用来创建它的任何设置。要更改队列设置，你必须删除队列并重新创建它。

#### 临时队列

- **自动删除队列**（auto_delete）
  - RabbitMQ 提供了一些队列，这些队列一旦使用完就会删除自己并且不会再使用。
  - 一旦消费者完成连接和检索消息，在断开连接时队列将被删除。
  - **任意数量的消费者**都可以对自动删除队列进行消费；队列只会在**没有消费者监听的时候**自行删除。
- **只允许单个消费者**（exclusive）
  - 在某些情况下，例如 RPC 工作流中的 RPC 回复队列，需要确保只有**单个消费者**能够消费队列中的消息。
  - 启用队列的独占属性需要**在队列创建时传递参数**。
  - 声明为 exclusive 的队列只能被声明时**所指定的同一个连接和信道所消费**。
  - 当创建队列的信道关闭时，独占队列也将自动被删除。
  - 在信道关闭之前，你可以根据需要**多次使用和取消 exclusive 队列的消费者**。
  - exclusive 队列自动删除行为的发生不会考虑是否已经发出了一个 Basic.Consume 请求，这是与 auto-delete 队列不同的。
- **自动过期队列**（expiration）
  - 创建一个具有 expiration 值的 RPC 回复队列，当该队列过期时就会被删除。使用一种被动的队列声明方式，就可以轮询队列的存在，并在看到有消息挂起或队列不再存在时采取动作。
  - 创建一个自动过期的队列非常简单，要做的事情就是使用 **x-expires 参数**声明一个队列，该参数以毫秒为单位设置队列的生存时间（Time To Live，TTL）
  - 严格的规定：
    - **队列只有在没有消费者的情况下才会过期。**
    - 队列只有在 TTL 周期之内没有收到 Basic.Get 请求时才会到期。一旦一个 Basic.Get 请求中已经包含了一个具有过期值的队列，那么过期设置无效，该队列将不会被自动删除。
    - 不能重新声明或更改 x-expires 的设置和参数。
    - RabbitMQ 不保证删除过期队列这一过程的时效性。

#### 永久队列

- **队列持久性**
  - 当声明那些在服务器重新启动之后仍然存在的队列时，应将 **durable 标志**设置为True。durable 标志告诉 RabbitMQ 希望队列被配置在服务器中，直到**Queue.Delete 请求**被调用为止。

- **队列中消息自动过期**
  - 消息级别的 TTL 设置允许服务器端对消息的最大生存时间进行限制。声明队列时同时指定**死信交换器和 TTL 值**将导致该队列中已到期的消息成为死信消息。
  - 与消息的过期时间属性（可能因消息而异）相反，x-message-ttl 队列设置强制规定了**队列中所有消息的最大生存时间**。
  - 创建一个自动使消息过期的队列将阻止实时仪表盘监听队列从而**避免接收到过时信息**。
- **最大长度队列**
  - 在声明队列时指定最大长度。
    - 如果在队列上设置了 **x-max-length 参数**，一旦达到最大值，RabbitMQ 会在添加新消息时**删除位于队列前端的消息**。
    - 在具有回滚缓冲区的聊天室中，用 x-max-length 声明的队列将确保请求最近 n 个消息的客户端总能够访问这些消息。
  - 如果使用死信交换器声明队列，则从队列前端移除的消息可能成为**死信**。、

#### 任意队列设置

- AMQP 规范的队列参数可用于设置**高可用性队列、死信交换器，消息过期时间、队列过期时间和队列最大长度。**

- **AMQP 参数：**

  | 参数名                    | 目的                                                         |
  | ------------------------- | ------------------------------------------------------------ |
  | x-dead-letter-exchange    | 用于路由那些不重新发送且被拒绝的消息的交换器                 |
  | x-dead-letter-routing-key | 用于死信消息的可选路由键                                     |
  | x-expires                 | 队列在指定的 ms 数后被删除                                   |
  | x-ha-policy               | 创建 HA 队列时，指定跨节点实现 HA 的模式                     |
  | x-ha-nodes                | HA 队列分布的节点                                            |
  | x-max-length              | 队列的最大消息数                                             |
  | x-message-ttl             | 以 ms 为单位的消息过期时间，**队列级别执行**                 |
  | x-max-priority            | 启用最大优先级值为 255（3.5.0 及更高版本）的队列优先排序功能 |

- **RabbitMQ 标志**

  | 参数名      | 目的             |
  | ----------- | ---------------- |
  | durable     | 队列持久化       |
  | exclusive   | 只允许单个消费者 |
  | auto_delete | 自动删除队列     |
  |             |                  |
  
  



## 跨集群的消息分发

- 插件实现的目标就是要将**最初发往上游节点的消息透明地转播到下游节点中去**
- 两个主要组件：**联合交换器和联合队列**
  - 联合交换器：允许发往上游节点交换器的消息被透明地发送至下游节点中相同名称的交换器上。
  - 联合队列：允许下游节点扮演上游节点中**共享队列**的消费者角色，为多个下游节点提供了轮询（round-robin）消费消息的能力。