## 分类

### 根据目的分类

- **创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。**
  1. 单例模式
  2. 原型
  3. 工厂方法
  4. 抽象方法
  5. 建造者

- **结构型模式：用于描述如何将类或对象按某种布局组成更大的结构**
  1. 代理
  2. 适配器
  3. 桥接
  4. 装饰
  5. 外观
  6. 享元
  7. 组合

- **行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。**
  1. 模板方法
  2. 策略
  3. 命令
  4. 职责链
  5. 状态
  6. 观察者
  7. 中介者
  8. 迭代器
  9. 访问者
  10. 备忘录
  11. 解释器

### 根据作用范围来分

- **类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。**
  1. 工厂方法
  2. （类）适配器
  3. 模板方法
  4. 解释器
- **对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。**
  - 除了上述 4 种。



## UML 类图及类图间的关系

1. 依赖关系（耦合性最弱）
2. 关联关系
   1. 一般关联
   2. 聚合关系（has-a）
   3. 组合关系（contains-a）
3. 泛化关系（继承：is-a）
4. 实现关系

## 基本原则（7条）

### 开闭原则

- **定义：软件实体应当对扩展开放，对修改关闭**
- 开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
- 作用（面向对象程序设计的终极目标）：
  - 软件测试只需对扩展的代码进行测试
  - 提高代码的可复用性
  - 提高软件的可维护性
- 实现方法：
  - 抽象约束、封装变化：通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而**将相同的可变因素封装在相同的具体实现类中**。
  - 软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

### 里式替换原则（继承）

- **定义：子类可以扩展父类的功能，但不能改变父类原有的功能。**
- 作用：
  - 实现开闭原则的重要方式之一。
  - 克服了继承中重写父类造成的可复用性变差的缺点。
  - 动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
- 实现方法：
  - 取消原来的继承关系，重新设计它们之间的关系。
  - 抽象成更基础的类。



### 依赖倒置原则（接口）

- 定义：
  - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
  - **核心思想**是**：要面向接口编程，不要面向实现编程。**
- 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。
- 主要作用：
  - 降低类间的耦合度。
  - 提高系统的稳定性。
  - 减少并行开发引起的风险。
  - 提高代码的可读性和可维护性。
- 实现方法：（编程遵循四点规则）
  - **每个类尽量提供接口或抽象类，或者两者兼备。**
  - **变量的声明类型尽量是接口或者是抽象类。**
  - **任何类都不应该从具体类派生。**
  - **使用继承时尽量遵循里式替换原则。**



### 单一职责原则（单一功能原则）

- 定义：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
- 优点：
  - 降低类的复杂度。
  - 提高类的可读性。
  - 提高系统的可维护性。
  - 变更引起的风险降低。
- 实现方法：
  - 需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。



### 接口隔离原则（有限度）

- 定义：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
- 接口隔离原则和单一职责原则的不同：
  - 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
  - 单一职责原则主要是**约束类**，它针对的是程序中的实现和细节；接口隔离原则主要**约束接口**，主要针对抽象和程序整体框架的构建。
- 优点：
  - 





## 设计模式（23）

### 观察者模式（对象行为型模式）

#### 定义与优缺点

- 定义：指多个对象间存在一对多的依赖关系，**当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新**。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。
- 主要优点：
  - 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
  - 目标与观察者之间建立了一套触发机制。
- 主要缺点：
  - 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。
  - 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。

#### 结构和实现

1. 模式的结构：（主要角色）
   - **抽象主题（Subject）角色**：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
   - **具体主题（Concrete  Subject）角色**：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
   - **抽象观察者（Observer）角色**：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
   - **具体观察者（Concrete Observer）角色**：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。



#### 和发布-订阅模式的区别

- 发布-



### 装饰模式（对象结构型模式）

- 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。
- 在 java 中，扩展一个类的功能，通过实现接口方法来实现。