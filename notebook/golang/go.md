## 〇、环境搭建

- 安装 go
  - 默认安装地址：C:/go
  - GOROOT_BOOTSTRAP=C:\go
  - 
- 安装 vscode
  - 插件：
    - 配置中文
    - go 环境
    - 





## 一、技术细节

### 下划线

- 用在 import：会调用包中的`init()`函数，让导入的包做初始化，但是却不使用包中其他功能。
- 用在返回值：Golang 中的函数返回值一般是多个，err 通常在返回值最后一个值。但是，有时候函数返回值中的某个值我们不关心，如何接收了这个值但不使用，代码编译会报错，因此需要将其忽略掉。
- 用在循环中：list、array 的 for 循环的第一项是 index，如果忽略的话则使用下划线。
- 匿名变量：任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。
  - **匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。**



## 二、Go 命令

### go build 

> 用于编译我们指定的源码文件或代码包以及它们的依赖包。

- 如果我们在执行`go build`命令时不后跟任何代码包，那么命令将试图编译当前目录所对应的代码包。

- Go 的三大类源码文件：

  > 1. 命令源码文件：命令源码文件总是作为可执行的程序的入口。
  > 2. 库源码文件：库源码文件一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等）
  > 3. 测试源码文件：用于对前两种源码文件中的程序实体的功能和性能进行测试。

- `go build`命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件。

- 在我们同时编译多个`main`包的源码文件时，要保证其中有且仅有一个`main`函数声明，否则编译是无法成功的。

- 命令`go build`会把编译命令源码文件后生成的结果文件存放到执行该命令时所在的目录下。

- `go build`命令的常用标记

  | 标记名称 | 标记描述                                                     |
  | -------- | ------------------------------------------------------------ |
  | -o       | 指定输出文件（在这个示例中指的是可执行文件）的名称。它是最常用的一个`go build`命令标记。（当使用标记`-o`的时候，不能同时对多个代码包进行编译。） |
  | -i       | 使`go build`命令安装那些编译目标依赖的且还未被安装的代码包。 |
  | -a       | 强行对所有涉及到的代码包（包含标准库中的代码包）进行重新构建，即使它们已经是最新的了。 |
  | -n       | 打印编译期间所用到的其它命令，但是并不真正执行它们。         |
  | -p n     | 指定编译过程中执行各任务的并行数量（确切地说应该是并发数量）。在默认情况下，该数量等于CPU的逻辑核数。但是在`darwin/arm`平台（即iPhone和iPad所用的平台）下，该数量默认是`1`。 |
  | -race    | 开启竞态条件的检测。不过此标记目前仅在 `linux/amd64`、`freebsd/amd64`、`darwin/amd64`和`windows/amd64`平台下受到支持。 |
  | -v       | 打印出那些被编译的代码包的名字。                             |
  | -work    | 打印出编译时生成的临时工作目录的路径，并在编译结束时保留它。在默认情况下，编译结束时会删除该目录。 |
  | -x       | 打印编译期间所用到的其它命令。注意它与`-n`标记的区别。       |

- 代码包编译

  > 从代码包编译的角度来说，如果代码包A依赖代码包B，则称代码包B是代码包A的依赖代码包（以下简称依赖包），代码包A是代码包B的触发代码包（以下简称触发包）。
  >
  > `go build`命令在执行时，编译程序会先查找目标代码包的所有依赖包，以及这些依赖包的依赖包，直至找到最深层的依赖包为止。在此过程中，如果发现有循环依赖的情况，编译程序就会输出错误信息并立即退出。此过程完成之后，所有的依赖关系也就形成了一棵含有重复元素的依赖树。对于依赖树中的一个节点（代码包）来说，它的直接分支节点（前者的依赖包），是按照代码包导入路径的字典序从左到右排列的。最左边的分支节点会最先被编译。编译程序会依此设定每个代码包的编译优先级。
  >
  > 执行`go build`命令的计算机如果拥有多个逻辑CPU核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：`依赖代码包 -> 当前代码包 -> 触发代码包`。

### go install

> 用于编译并安装指定的代码包及它们的依赖包。
>
>  
>
> 实际上，`go install`命令只比`go build`命令多做了一件事，即：安装编译后的结果文件到指定目录。

- 我们只能使用安装代码包的方式来安装库源码文件，而不能在`go install`命令罗列并安装它们。另外，`go install`命令目前无法接受标记`-o`以自定义结果文件的存放位置。这也从侧面说明了`go install`命令不支持针对库源码文件的安装操作。

### go get

> 命令`go get`可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。
>
>  
>
> 更严格地讲，`go get`命令所做的是从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装。

- 一般情况下，为了分离自己与第三方的代码，我们会设置两个或更多的工作区。

- 另一方面，如果我们想把一个项目上传到Github网站（或其他代码托管网站）上并被其他人使用的话，那么我们就应该把这个项目当做一个代码包来看待。

  > `go get `命令会将项目下的所有子目录和源码文件存放到第一个工作区的 src 目录下，而 src 目录下的所有子目录都会是某个代码包导入路径的**一部分或者全部**。也就是说，我们应该直接**在项目目录下存放子代码包和源码文件**，并且**直接存放在项目目录下的源码文件所声明的包名应该与该项目名相同**（除非它是命令源码文件）。这样做可以让其他人使用 `go get `命令从 Github 站点上下载你的项目之后直接就能使用它。

- 远程导入

- 自定义代码包远程导入路径

- 命令特有标记

  | 标记名称  | 标记描述                                                     |
  | --------- | ------------------------------------------------------------ |
  | -d        | 让命令程序只执行下载动作，而不执行安装动作。                 |
  | -f        | 仅在使用`-u`标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里Fork过来的，那么这样做就尤为重要了。 |
  | -fix      | 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。 |
  | -insecure | 允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。 |
  | -t        | 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 |
  | -u        | 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 |

- 智能下载：在使用它检出或更新代码包之后，它会寻找与本地已安装Go语言的版本号相对应的标签（tag）或分支（branch）。



### go clean

> 执行`go clean`命令会删除掉执行其它命令时产生的一些文件和目录。



### go fmt 与 gofmt

> `go fmt` 命令会按照 Go 语言代码规范格式化指定代码包中的所有 Go 语言源码文件的代码。
>
>  
>
> `go fmt` 命令只会格式化被直接保存在指定代码包对应目录下的 Go 语言源码文件。

- 与`go doc`命令和`godoc`命令的关系类似，`go fmt`命令是`gofmt`命令的简单封装。

- 使用：

  - 在命令行输入 gofmt –w program.go 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容（如果不加参数 -w 则只会打印格式化后的结果而不重写文件）；
  - gofmt -w *.go 会格式化并重写所有 Go 源文件
  - gofmt map1 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。

- gofmt 命令的标记

  | 标记名称    | 标记描述                                                     |
  | ----------- | ------------------------------------------------------------ |
  | -n          | 以让命令程序仅打印出内部使用的`gofmt`命令及其标记和参数而不真正执行它。 |
  | -x          | 使命令程序既打印又执行这个命令                               |
  | -cpuprofile | 把 CPU 概要写入指定文件。文件的路径应该作为此标记的值。      |
  | -d          | 显示格式化前后的不同（如果有的话），而不是直接格式化那些代码。 |
  | -e          | 报告目标源码文件中的所有错误。默认情况下，仅会显示前10个错误。 |
  | -l          | 仅把那些不符合格式化规范的、需要被命令程序改写的源码文件的绝对路径打印到标准输出。而不是把改写后的全部内容都打印到标准输出。 |
  | -r          | 添加形如“a[b:len(a)] -> a[b:]”的重写规则。如果我们需要自定义某些额外的格式化规则，就需要用到它。规则字符串应该作为此标记的值。 |
  | -s          | **简化文件中的代码。**                                       |
  | -w          | 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 |

- `gofmt`命令已支持但不限于如下自定义替换操作：

  - 程序实体名称的替换。
  - 程序实体类型的替换，其中也包含函数的参数和结果的类型的替换。
  - 多余圆括号的清除。
  - 数值操作的替换。
  - 基于参数列表的函数调用替换。

- 当我们执行 `gofmt` 命令且没有加任何参数的时候，该命令将会进入到交互模式。在这种模式下，我们可以直接在命令行界面中输入源码，并以 Ctrl-d/Ctrl-z 结束。

### go doc 与 godoc

#### go doc

> 可以打印附于 Go 语言程序实体上的文档。我们可以通过把**程序实体的标识符**作为该命令的参数来达到查看其文档的目的。

- Go 语言的程序实体：

  > Go语言的程序实体，是指变量、常量、函数、结构体以及接口。
  >
  > 而程序实体的标识符即是代表它们的名称。标识符又分非限定标识符和限定标识符。其中，限定标识符一般用于表示某个代码包中的程序实体或者某个结构体类型中的方法或字段。例如，标准库代码包 `io` 中的名为 `EOF` 的变量用限定标识符表示即 `io.EOF`。又例如，如果我有一个 `sync.WaitGroup` 类型的变量 `wg` 并且想调用它的 `Add` 方法，那么可以这样写 `wg.Add()`。其中，`wg.Add` 就是一个限定标识符，而后面的 `()` 则代表了调用操作。

- go doc 命令的标记说明：

  | 标记名称 | 标记描述                                                     |
  | -------- | ------------------------------------------------------------ |
  | -c       | 加入此标记后会使 `go doc` 命令区分参数中字母的大小写。默认情况下，命令是大小写不敏感的。 |
  | -cmd     | 加入此标记后会使 `go doc` 命令同时打印出 `main` 包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的。 |
  | -u       | 加入此标记后会使 `go doc` 命令同时打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的。 |

- 一般用法

  - go doc package 获取包的文档注释，例如：go doc fmt 会显示使用 godoc 生成的 fmt 包的文档注释。
  - go doc package/subpackage 获取子包的文档注释，例如：go doc container/list。
  - go doc package function 获取某个函数在某个包中的文档注释，例如：go doc fmt Printf 会显示有关 fmt.Printf() 的使用说明。

- > 结构体类型中的字段的文档是无法被单独打印的。

- `go doc `命令根据参数查找代码包或程序实体的顺序是：先 Go 语言根目录（即 **GOROOT** 所环境变量指定的那个目录）后工作区目录（即 **GOPATH** 环境变量包含的那些目录）。

- 在给定两个参数时，`go doc` 会打印出所有匹配的文档，而不是像给定一个参数时那样只打印出第一个匹配的文档。这对于查找只有大小写不同的多个方法（如 `New` 和 `new `）的文档来说非常有用。



#### godoc 

> 同样用于展示指定代码包的文档。在 Go 语言的 1.13 版本之后，它不是一个内置的标准命令。

- 安装：

  ```bash
  go get golang.org/x/tools/cmd/godoc
  ```

- 标记：
  - -http
  - -index

### go run

> `go run `命令可以编译并运行命令源码文件。
>
> `go run`命令包含了两个动作：编译命令源码文件和运行对应的可执行文件。

- 由于它其中包含了编译动作，因此它也可以接受所有可用于 `go build` 命令的标记。除了标记之外，`go run` 命令只接受 Go 源码文件作为参数，而不接受代码包。与 `go build` 命令和 `go install` 命令一样，`go run` 命令也不允许多个命令源码文件作为参数，即使它们在同一个代码包中也是如此。而原因也是一致的，多个命令源码文件会都有 main 函数声明。



### go test

> `go test`命令用于对Go语言编写的程序进行测试。这种测试是以代码包为单位的。

```bash
# 指定代码包
go test xxx		# GOROOT 目录下
# 当前代码包
go test
# 指定源码文件
go test xxxx_test.go xxxx.go
```

- 放在同一个包中

  >  一般情况下，我们会把测试源码文件与被测试的源码文件放在同一个代码包中。并且，这些源码文件中声明的包名也都是相同的。除此之外我们还有一种选择，那就是测试源码文件中声明的包名可以是所属包名再加“_test”后缀。我们把这种测试源码文件叫做包外测试源码文件。不过，包外测试源码文件存在一个弊端，那就是在它们的测试函数中无法测试被测源码文件中的包级私有的程序实体，比如包级私有的变量、函数和结构体类型。这是因为这两者的所属代码包是不相同的。所以，我们一般很少会编写包外测试源码文件。

- 常用标记

  | 标记名称 | 标记描述                                                     |
  | -------- | ------------------------------------------------------------ |
  | -c       | 生成用于运行测试的可执行文件，但不执行它。这个可执行文件会被命名为“pkg.test”，其中的“pkg”即为被测试代码包的导入路径的最后一个元素的名称。 |
  | -i       | 安装/重新安装运行测试所需的依赖包，但不编译和运行测试代码。  |
  | -o       | 指定用于运行测试的可执行文件的名称。追加该标记不会影响测试代码的运行，除非同时追加了标记`-c`或`-i`。 |



### go list

> `go list`命令的作用是列出指定的代码包的信息。
>
>  
>
> `go list`命令很有用。它可以为我们提供指定代码包的更深层次的信息。这些信息往往是我们无法从源码文件中直观看到的。

```bash
# 以容错模式加载和分析指定的代码包。
go list -e
# 代码包的结构体实例用JSON的样式打印出来。
go list -json
# 查看其中的一些字段
go list -f {{.ImportPath}}
```



### go fix 与 go tool fix

> 命令 `go fix `会把指定代码包的所有 Go 语言源码文件中的旧版本代码修正为新版本的代码。这里所说的版本即Go语言的版本。
>
>  
>
> 命令`go fix`其实是命令`go tool fix`的简单封装。

- *`go tool fix`命令的标记说明*

- | 标记名称 | 标记描述                                                     |
  | -------- | ------------------------------------------------------------ |
  | -diff    | 不将修正后的内容写入文件，而只打印修正前后的内容的对比信息到标准输出。 |
  | -r       | 只对目标源码文件做有限的修正操作。该标记的值即为允许的修正操作的名称。多个名称之间用英文半角逗号分隔。 |
  | -force   | 使用此标记后，即使源码文件中的代码已经与Go语言的最新版本相匹配了，也会强行执行指定的修正操作。该标记的值就是需要强行执行的修正操作的名称，多个名称之间用英文半角逗号分隔。 |



### go vet 与 go tool vet

> 命令 `go vet ` 是一个用于检查 Go 语言源码中静态错误的简单工具。
>
>  
>
> `go vet`命令是`go tool vet`命令的简单封装。

- go tool vet 命令的标记说明

  | 标记名称            | 标记描述                                                     |
  | ------------------- | ------------------------------------------------------------ |
  | -all                | 进行全部检查。如果有其他检查标记被设置，则命令程序会将此值变为false。默认值为true。 |
  | -asmdecl            | 对汇编语言的源码文件进行检查。默认值为false。                |
  | -assign             | 检查赋值语句。默认值为false。                                |
  | -atomic             | 检查代码中对代码包sync/atomic的使用是否正确。默认值为false。 |
  | -buildtags          | 检查编译标签的有效性。默认值为false。                        |
  | -composites         | 检查复合结构实例的初始化代码。默认值为false。                |
  | -compositeWhiteList | 是否使用复合结构检查的白名单。仅供测试使用。默认值为true。   |
  | -methods            | 检查那些拥有标准命名的方法的签名。默认值为false。            |
  | -printf             | 检查代码中对打印函数的使用是否正确。默认值为false。          |
  | -printfuncs         | 需要检查的代码中使用的打印函数的名称的列表，多个函数名称之间用英文半角逗号分隔。默认值为空字符串。 |
  | -rangeloops         | 检查代码中对在```range```语句块中迭代赋值的变量的使用是否正确。默认值为false。 |
  | -structtags         | 检查结构体类型的字段的标签的格式是否标准。默认值为false。    |
  | -unreachable        | 查找并报告不可到达的代码。默认值为false。                    |



### go tool pprof	===> 性能分析

> 使用 `go tool pprof` 命令来交互式的访问概要文件的内容。

- 生成概要文件

  > 在Go语言中，我们可以通过标准库的代码包 `runtime` 和 `runtime/pprof` 中的程序来生成三种包含实时性数据的概要文件，分别是 CPU 概要文件、内存概要文件和程序阻塞概要文件。

  - CPU 概要文件
  - 内存概要文件
  - 程序阻塞概要文件
  - 互斥锁分析

### go env

> 命令`go env`用于打印Go语言的环境信息。



- go env 命令可以打印出的  go 语言通用环境信息

  | 名称        | 说明                                     |
  | ----------- | ---------------------------------------- |
  | CGO_ENABLED | 指明cgo工具是否可用的标识。              |
  | GOARCH      | 程序构建环境的目标计算架构。             |
  | GOBIN       | 存放可执行文件的目录的绝对路径。         |
  | GOCHAR      | 程序构建环境的目标计算架构的单字符标识。 |
  | GOEXE       | 可执行文件的后缀。                       |
  | GOHOSTARCH  | 程序运行环境的目标计算架构。             |
  | GOOS        | 程序构建环境的目标操作系统。             |
  | GOHOSTOS    | 程序运行环境的目标操作系统。             |
  | GOPATH      | 工作区目录的绝对路径。                   |
  | GORACE      | 用于数据竞争检测的相关选项。             |
  | GOROOT      | Go语言的安装目录的绝对路径。             |
  | GOTOOLDIR   | Go工具目录的绝对路径。                   |

## 三、命令行参数

- os.Args变量是一个字符串（string）的*切片*（slice），它在程序启动后读取命令行输入的参数。
  - os.Args的第一个元素：**os.Args[0]，是命令本身的名字**；其它的元素则是程序启动时传给它的参数。
- flag 包：
  - `flag.Parse()` 扫描参数列表（或者常量列表）并设置 flag, `flag.Arg(i)` 表示第 i 个参数。Parse() 之后 `flag.Arg(i)` 全部可用，`flag.Arg(0)` 就是第一个真实的 flag，而不是像 os.Args(0) 放置程序的名字。
  - `flag.Narg()` 返回参数的数量。解析后 flag 或常量就可用了。
  - `flag.Bool()` 定义了一个默认值是 false 的 flag：当在命令行出现了第一个参数（这里是 "n"），flag 被设置成 true（NewLine 是 `*bool` 类型）。flag 被解引用到 `*NewLine`，所以当值是 true 时将添加一个 newline（"\n"）。
  - `flag.PrintDefaults()` 打印 flag 的使用帮助信息
  - `flag.VisitAll(fn func(*Flag))` 是另一个有用的功能：按照字典顺序遍历 flag，并且对每个标签调用 fn
  - `flag.Usage`：输出使用方法
  - `flag.Args`：返回解析完命令行参数后的其他参数



## 四、可见性规则

- 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个**大写字母开头**，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以**小写字母开头**，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）
- 包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名（通过使用包的别名来解决包名之间的名称冲突）

## 五、基本结构和基本数据类型

- **指针**
  - **一个指针变量可以指向任何一个值的内存地址**
  - **注意事项**：
    - 在书写表达式类似 `var p *type` 时，切记在 `*` 号和指针名称间留有一个空格，因为 `var p*type` 是语法正确的，但是在更复杂的表达式中，它容易被误认为是一个乘法表达式！
  - 符号 `*` 可以放在一个指针前，如 `*intP`，那么它将得到这个指针指向地址上所存储的值；这被称为**反引用（或者内容或者间接引用）操作符**；另一种说法是**指针转移**。
- **切片**：
  - 切片不能被重新分片以获取数组的前一个元素。
  - **注意** 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针！！
  - **切片的追加**：x = append(x, y...)
- **函数**：
  - 内置函数：如：len、cap、append、panic 等等
  - 递归函数解决方法：通过**懒惰求值**的技术解决。
  - **可以将函数作为参数传递**，然后在其它函数内调用执行，一般称之为回调。
- **闭包（匿名函数）**
  - 匿名函数可以直接进行调用。
  - 匿名函数可以被赋值给变量并作为值使用。
  - **闭包函数保存并积累其中的变量的值**，不管外部函数退出与否，它都能够继续操作外部函数中的局部变量。
  - **闭包的应用**：
    - **包装函数**：它们会预先定义好 1 个或多个参数以用于包装
    - 使用闭包来完成更加简洁的错误检查
    - 常用于 goroutine 和 管道操作。
- 高阶函数：
  - 可以**返回其它函数**的函数和**接受其它函数作为参数**的函数均被称之为高阶函数，是函数式语言的特点。

## 六、结构体和方法

- 方法：带接收器的函数
- String() 方法===》类似于 toString 方法
- 垃圾回收：
  - 独立进程
  - 搜索不再使用的变量然后释放它们的内存
- 工厂方法
  - 使用初始化来简便的实现构造函数。
  - 如果 `File` 是一个结构体类型，那么表达式 `new(File)` 和 `&File{}` 是等价的。
  - 强制使用工厂方法：将 struct 的开头命名为小写，就可以禁止使用 new 函数，强制用户使用工厂方法，从而使类型变成私有的。
- **结构体比较**：
  - 结构体只能比较是否相等，但是不能比较大小。
  - 相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关。
  - 如果 struct 的所有成员都可以比较，则该 struct 就可以通过 == 或 != 进行比较是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等；
  - 可比较的有 bool、数值型、字符、指针、数组等；不可比较的有：切片、map、函数等。



## 七、接口和反射

- 接口可以嵌套接口
- **类型断言：**使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。
  - 使用 **类型断言** 来测试在某个时刻 `varI` 是否包含类型 `T` 的值：v := varI.(T)
  - value, ok := x.(T) ===》其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。
  - 使用 **type-switch** 进行类型判断
- **空接口**：
  - 构建通用类型或包含不同类型变量的数组
  - 所有类型都至少实现了空接口。
  - 注意事项：
    1. 空接口可以承载任意值，但不代表任意类型就可以承接空接口类型的值。（任意类型值 ===> 空接口；空接口 ===/> 任意类型） 
    2. 当空接口承载数组和切片后，该对象无法再进行切片
    3. 当你使用空接口来接收任意类型的参数时，它的静态类型是 interface{}，但动态类型（是 int，string 还是其他类型）我们并不知道，因此需要使用类型断言。
- **反射包**：
  - 变量的最基本信息就是类型和值：反射包的 `Type` 用来表示一个 Go 类型，反射包的 `Value` 为 Go 值提供了反射接口。
  - `reflect.TypeOf` 和 `reflect.ValueOf`，返回被检查对象的类型和值
  - 反射是通过检查一个接口的值，变量首先被转换成空接口。
  - **通过反射修改（设置）值**：反射中有些内容是需要用地址去改变它的状态的。
  - **结构体中只有被导出字段（首字母大写）才是可设置的；**
- **Go 的动态类型和动态方法调用**
- **空接口和函数重载**：把 T 换为空接口，那么可以知道任何类型的变量都是满足 T (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。

### go 语言的反射三定律

- 反射第一定律：反射可以将“接口类型变量”转换为“反射类型变量”
  - 反射类型指 reflect.Type 和 reflect.Value 
- 反射第二定律：反射可以将“反射对象类型”转换为“接口类型变量”
  - Interface 方法和 ValueOf 函数作用相反，返回值的静态类型是 interface{}
- 反射第三定律：如果要修改“反射类型对象”，其值必须是“可写的”（settable）。
  - **可写性** 类似于寻址能力，但是更严格。它是反射类型变量的一种属性，赋予该变量修改底层存储数据的能力。**可写性** 最终由一个事实决定：反射对象是否存储了原始值。
  - **只要反射对象要修改它们表示的对象，就必须获取它们表示的对象的地址。**

## 八、协程（goroutine）与通信（channel）

- 基本概念：

  - **并发程序**：可能是并行的，也可能不是。
  - **竞态**：内存中的数据共享会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果。**不要使用全局变量或者共享内存。**(sync 包)
  - **协程**：
    - 使用少量的内存和资源
    
    - 协程可以运行在多个操作系统线程之间，也可以运行在线程之内
    
    - Go 的协程和通道支持确定性的并发方式
    
      > 使用 4K 的栈内存就可以在堆中创建它们。因为创建非常廉价，必要的时候可以轻松创建并运行大量的协程（在同一个地址空间中 100,000 个连续的协程）。并且它们对栈进行了分割，从而动态的增加（或缩减）内存的使用；**栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。**
  - **两种并发方式**：
    - 确定性的（明确定义排序）	===> go 支持
    - 非确定性的（加锁/互斥，从而未定义排序）
  - 通道（channel）
    
    - 数据通过通道：同一时间只有一个协程可以访问数据 ===> 所以不会出现数据竞争

- 常用方法：

  - runtime.Gosched()：让出处理器，允许运行其他协程；它不会使当前协程挂起，所以它会自动恢复执行。使用 `Gosched()` 可以使计算均匀分布，使通信不至于迟迟得不到响应。
  -  

- 重要概念：

  - **使用 GOMAXPROCS**：了解运行时有多少个协程同时执行。
  - n 核：设置 `GOMAXPROCS` 为 `n-1` 以获得最佳性能，同时保证 `协程的数量 > 1 + GOMAXPROCS > 1`
  - **计时器（Ticker）和定时器（Timer）**：

    - Ticker：周期性执行任务
    - Timer：在 Duration 时间后，只执行一次任务
  - 使用锁和通道的情景：（优先使用通道）

    - **使用锁的情景**：
      1. 访问共享数据结构中的缓存信息
      2. 保存应用程序上下文和状态信息数据
    - **使用通道的情景**：
      1. 与异步操作的结果进行交互
      2. 分发任务
      3. 传递数据所有权
  - **多路复用**：
  - **多核运算处理大量数据**：一个更有效的计算是让每一个步骤都作为一个协程独立工作。每个步骤都从上一步的输出通道获取输入数据。

### 信道（channel）===> 协程间通信

- 通道服务于通信的两个目的：**值的交换，同步的**，保证了两个计算（协程）任何时候都是可知状态。

- 声明和实例化

  ```go
  // 方式1
  var ch1 chan string
  ch1 = make(chan string)
  // 方式2
  ch1 := make(chan string)
  ```

  

- 通信操作符：<-

- 信道的数据操作，无非就两种：**发送数据与读取数据**

- 为了可读性，通道的命名通常以 `ch` 开头或者包含 `chan`

- 如果 2 个协程需要通信，必须给他们同一个通道作为参数才行。

- **通道阻塞**：通道的发送 / 接收操作在对方准备好之前是阻塞的：

  1. 对于同一个通道，**发送操作**（协程或者函数中的），在接收者准备好之前是阻塞的。
  2. 对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用。
  3. 如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。

  

- **同步通道 - 使用带缓冲的通道**

- **信号量模式**：实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题。通过通道发送信号告知处理已经完成（在协程中）。

- **通道工厂模式**：不将通道作为参数传递给协程，而用函数来生成一个通道并返回（工厂角色）；函数内有个匿名函数被协程调用。

- **通道迭代模式**：为容器的类型定义一个方法 `Iter()`，返回一个只读的通道。

- **生产者消费者模式**：

- **通道的方向**：通道类型可以用注解来表示它只发送或者只接收。

  - **管道和选择器模式**：通过使用方向注解来限制协程对通道的操作。

- **关闭通道**：只有发送者需要关闭通道，接收者永远不会需要。

  - 关闭：close(ch)；检测是否关闭：v, ok := <-ch，和 if 语句一起使用
  - 使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭

- **缓冲通道与无缓冲通道**

  - 缓冲通道：允许信道里存储一个或多个数据，这意味着，设置了缓冲区后，发送端和接收端可以处于异步的状态。
  - 无缓冲通道：发送端和接收端是同步运行的。

- **双向信道和单向信道**

  - 双向信道：默认定义的是双向信道。
  - 单向信道：分为**只读信道**和**只写信道**。
    - `<-chan` 表示这个信道，只能从里发出数据，对于程序来说就是只读
    - `chan<-` 表示这个信道，只能从外面接收数据，对于程序来说就是只写

- **用信道来做锁**

  - 当信道里的数据量已经达到设定的容量时，此时再往里发送数据会阻塞整个程序。当信道里的数据量已经达到设定的容量时，此时再往里发送数据会阻塞整个程序。
  
- **select**：使用 select 切换协程（用法类似 switch）——轮询机制

  - `default` 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 `break` 或者 `return`，select 就结束了。
  - `select` 做的就是：选择处理列出的多个通信情况中的一个。

- **惰性生成器**

  - 通过巧妙地使用空接口、闭包和高阶函数，我们能实现一个通用的惰性生产器的工厂函数 BuildLazyEvaluator（这个应该放在一个工具包中实现）。
  - 工厂函数需要一个函数和一个初始状态作为输入参数，返回一个无参、返回值是生成序列的函数。
  - 传入的函数需要计算出下一个返回值以及下一个状态参数。在工厂函数中，创建一个通道和无限循环的 go 协程。返回值被放到了该通道中，返回函数稍后被调用时从该通道中取得该返回值。
  - 每当取得一个值时，下一个值即被计算。

- **Futures 模式**：Futures 模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于 Futures 需要返回一个值。

### 注意事项

1. 关闭一个**未初始化的 channel** 会产生 panic。
2. 重复关闭**同一个 channel** 会产生 panic。
3. 向一个已关闭的 channel 发送消息会产生 panic。
4. 从已关闭的 channel 读取消息不会产生 panic，且能读出 channel 中还未被读取的消息，若消息均已被读取，则会读取到该类型的零值。
5. 从已关闭的 channel 读取消息永远不会阻塞，并且会返回一个为 false 的值，用以判断该 channel 是否已关闭（x,ok := <- ch）
6. 关闭 channel 会产生一个广播机制，所有向 channel 读取消息的 goroutine 都会收到消息
7. channel 在 Golang 中是一等公民，它是线程安全的，面对并发问题，应首先想到 channel。

### 死锁案例

- 对于无缓冲信道，在接收者未准备好之前，发送操作是阻塞的（解决方法：）
  1. 使接收者代码在发送者之前执行。
  2. 使用缓冲信道，而不使用无缓冲信道。



### WaitGroup

- 优雅地处理主程序阻塞的情况。

- 主要方法：

  - Add：初始值为 0，你传入的值会往计数器上加，这里直接传入你子协程的数量
  - Done：当某个子协程完成后，可调用此方法，会从计数器上减一，通常可以使用 defer 来调用。
  - Wait：阻塞当前协程，直到实例里的计数器归零。

- 实例：

  ```go
  func worker(x int, wg *sync.WaitGroup)  {
  	defer wg.Done()
  	for i := 0; i < 5; i++ {
  		fmt.Printf("worker %d: %d\n", x, i)
  	}
  }
  
  func main() {
  	var wg sync.WaitGroup
  	wg.Add(2)
  	go worker(1, &wg)
  	go worker(2, &wg)
  	wg.Wait()
  }
  ```

### 锁机制

-  Mutex 锁

  - Mutex 锁的两种定义方法

  ```go
  // 第一种
  var lock *sync.Mutex
  lock = new(sync.Mutex)
  
  // 第二种
  lock := &sync.Mutex{}
  ```

  - 注意点：
    - 同一协程里，不要在尚未解锁时再次使加锁
    - 同一协程里，不要对已解锁的锁再次解锁
    - 加了锁后，别忘了解锁，必要时使用 defer 语句

- 读写锁：RWMutex（将程序对资源的访问分为读操作和写操作）

  - 为了保证数据的安全，它规定了当有人还在读取数据（即读锁占用）时，不允计有人更新这个数据（即写锁会阻塞）

  - 为了保证程序的效率，多个人（线程）读取数据（拥有读锁）时，互不影响不会造成阻塞，它不会像 Mutex 那样只允许有一个人（线程）读取同一个数据。

  - 两种定义方式：

    ```go
    // 第一种
    var lock *sync.RWMutex
    lock = new(sync.RWMutex)
    
    // 第二种
    lock := &sync.RWMutex{}
    ```

### 线程模型

- 内核级线程模型
- 用户级线程模型
- 两级线程模型（也称混合型线程模型）
  - P M D

### Context（优雅关闭协程）==> 退出通知和元数据传递

- 可以看到 Context 接口共有 4 个方法
  - `Deadline`：返回的第一个值是 **截止时间**，到了这个时间点，Context 会自动触发 Cancel 动作。返回的第二个值是 一个布尔值，true 表示设置了截止时间，false 表示没有设置截止时间，如果没有设置截止时间，就要手动调用 cancel 函数取消 Context。
  - `Done`：返回一个只读的通道（只有在被 cancel 后才会返回），类型为 `struct{}`。当这个通道可读时，意味着 parent context 已经发起了取消请求，根据这个信号，开发者就可以做一些清理动作，退出 goroutine。
  - `Err`：返回 context 被 cancel 的原因。
  - `Value`：返回被绑定到 Context 的值，是一个键值对，所以要通过一个 Key 才可以获取对应的值，这个值一般是线程安全的。
- 根 context：
  - 创建 Context 必须要指定一个 父 Context，而 go 已经实现了 2 个context，都是以这两个内置的 context 作为最顶层的 parent context，衍生出更多的子 context。
  - **Background 和 TODO**（本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context）：
    - Background ：主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。
    - TODO：如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO。
- context 的继承衍生
  - 第一个参数都是接收一个父 context，通过一次继承，就多实现了一个功能。
  - withCancel、WithDeadline、WithTimeout、WithValue
- 注意事项：
  - 通常 Context 都是做为函数的第一个参数进行传递（规范性做法），并且变量名建议统一叫 ctx
  - Context 是**线程安全**的，可以放心地在多个 goroutine 中使用。
  - 当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到 取消的信号
  - 不要把原本可以由函数参数来传递的变量，交给 Context 的 Value 来传递。
  - 当一个函数需要接收一个 Context 时，但是此时你还不知道要传递什么 Context 时，可以先用 context.TODO 来代替，而不要选择传递一个 nil。
  - 当一个 Context 被 cancel 时，继承自该 Context 的所有 子 Context 都会被 cancel。





## 九、读写数据

- 标准输入/输出

  ```go
  // 标准输入
  os.Stdin
  // 标准输出
  os.Stdout
  // 用于显示错误信息，大多数情况下等同于 os.Stdout
  os.Stderr
  ```

- fmt 提供的 Scan 和 Sscan 开头的函数：

  - `Scanln` 扫描来自**标准输入**的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。
  - `Sscan` 和以 `Sscan` 开头的函数则是从**字符串**读取，除此之外，与 `Scanf` 相同。

- bufio 包提供的缓冲读取（buffered reader）来读取数据

  ```go
  // 创建一个读取器 bufio.Reader，并将其与标准输入绑定
  inputReader := bufio.NewReader(os.Stdin)
  
  // 返回的读取器对象提供一个方法 ReadString(delim byte)，该方法从输入中读取内容，直到碰到 delim 指定的字符，然后将读取到的内容连同 delim 字符一起放到缓冲区。
  inputReader.ReadString('\n')
  ```

- 文件读写：

  - 文件使用指向 `os.File` 类型的指针来表示的，也叫做文件句柄。
  - ioutil.ReadFile() ： **将整个文件的内容读到一个字符串里：**
  - inputReader.Read(buf)：**带缓冲的读取**
  - outputWriter.WriteString(outputString)：**写文件**
  - 如果**数据是按列排列并用空格分隔的**，可以使用 `fmt` 包提供的以 FScan 开头的一系列函数来读取他们
  - path/filepath 包：提供了跨平台的函数，用于**处理文件名和路径。**
  - compress 包：**读取压缩文件的功能**（支持的压缩文件格式：bzip2、flate、gzip、lzw 和 zlib）
  - os.OpenFile 函数：有三个参数：文件名、一个或多个标志（使用逻辑运算符 “|” 连接），使用的文件权限。
  - **文件操作**：使用 os 包内的函数

- **用 defer 关闭文件**

- 用切片缓存读写文件：

  - 在缓冲写入的最后千万不要忘了使用 `Flush()`，否则最后的输出不会被写入。



## 十、go 常用的包

| 输入输出                                                     | 文本处理（字符串和文本内容的处理）          | 网络             | 系统                                                         | 数据结构与算法    | 运行时  |
| ------------------------------------------------------------ | ------------------------------------------- | ---------------- | ------------------------------------------------------------ | ----------------- | ------- |
| bufio：在 io 的基础上提供了缓存功能                          | encoding/json：提供了对JSON的基本支持       | net              | os：提供了对操作系统功能的非平台相关访问接口。接口为 Unix 风格。提供的功能包括：<b>文件操作、进程管理、信号和用户账号等</b>。 | math              | runtime |
| fmt：实现了格式化的输入输出操作                              | bytes：提供了对字节切片操作的函数           | http：强大而易用 | syscall                                                      | sort              | reflect |
| io：实现了一系列非平台相关的 IO 相关接口和实现（读写文件时使用） | strings                                     | expvar           | sync：提供了基本的同步原语。<b>在多个 goroutine 访问共享资源的时候，需要使用 sync 中提供的锁机制。</b> | container         | go      |
| log                                                          | strconv：提供字符串与基本数据类型互转的能力 |                  | time                                                         | crypto            |         |
| flag：<b>提供命令行参数的规则定义和传入参数解析的功能。</b>绝大部分的命令行程序都需要用到这个包。 | text                                        |                  | unsafe                                                       | hash              |         |
|                                                              | mime                                        |                  |                                                              | archive           |         |
|                                                              | unicode                                     |                  |                                                              | compress          |         |
|                                                              | regexp                                      |                  |                                                              | image：图像编解码 |         |
|                                                              | index                                       |                  |                                                              |                   |         |
|                                                              | path：处理路径字符串                        |                  |                                                              |                   |         |





### flag：处理命令行参数

常用方法：

- flag.Usage：输出使用方法
- flag.Parse：执行解析
- flag.Args：返回解析完命令行参数后的其他参数



## 十一、错误处理（defer-panic-and-recover 机制）

- **testing 包**被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能。
  - **基准测试**：测试代码中必须包含以 `BenchmarkZzz` 打头的函数并接收一个 `*testing.B` 类型的参数

- **性能调优**
  - 使用 go test 调试
  - 使用 gopprof 调试
- 



## 十二、http

```go
// http 包默认的路由器
type ServeMux struct {
    mu sync.RWMutex   		// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制
    m  map[string]muxEntry  // 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式
    hosts bool 				// 是否在任意的规则中带有 host 信息
}

type muxEntry struct {
    explicit bool   // 是否精确匹配
    h        Handler // 这个路由表达式对应哪个 handler
    pattern  string  // 匹配字符串
}

// Handler 实现
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)		// 路由实现器
}

type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}


func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    // 如果是*那么关闭链接
    if r.RequestURI == "*" {
        w.Header().Set("Connection", "close")
        w.WriteHeader(StatusBadRequest)
        return
    }
    // 返回对应设置路由的处理 Handler
    h, _ := mux.Handler(r)
    h.ServeHTTP(w, r)
}

func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
    if r.Method != "CONNECT" {
        if p := cleanPath(r.URL.Path); p != r.URL.Path {
            _, pattern = mux.handler(r.Host, p)
            return RedirectHandler(p, StatusMovedPermanently), pattern
        }
    }   
    return mux.handler(r.Host, r.URL.Path)
}

func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()

    // Host-specific pattern takes precedence over generic ones
    if mux.hosts {
        h, pattern = mux.match(host + path)
    }
    if h == nil {
        h, pattern = mux.match(path)
    }
    if h == nil {
        h, pattern = NotFoundHandler(), ""
    }
    return
}
```





## 十三、常见的陷阱和错误

- 误用短声明（:=）导致变量覆盖
  - 只能在函数内部使用简短模式；
- 误用字符串：**应该使用一个字符数组代替字符串，将字符串内容写入一个缓存中。**
- **defer 仅在函数返回时才会执行，在循环的结尾或其他一些有限范围的代码内不会执行。**
- **何时使用 new() 和 make()**：
  - 切片（slice）、映射（map）和通道（channel），使用 make 
  - 数组（array）、结构体（struct）和所有的值类型，使用 new 
- **不需要将一个指向切片的指针传递给函数**
  - 切片实际是一个指向潜在数组的指针。我们常常需要把切片作为一个参数传递给函数是因为：实际就是传递一个指向变量的指针，在函数内可以改变这个变量，而不是传递数据的拷贝。
- **永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。**
- **使用指针代替值类型作为参数传递没有任何用处**。（值类型时传递拷贝，但是内存分配是在栈上，分配快速且开销不大；而传递指针，go 编译器在大多数时候会创建一个对象，并将对象移动到堆上，导致额外的内存分配）
- **当且仅当代码中并发执行非常重要，才使用协程和通道。**
- 



## 十四、其他知识

- 内存对齐
  - **调整结构体内成员变量的字段顺序**就能达到缩小结构体占用大小的用处。
