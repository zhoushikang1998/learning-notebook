## 一、Lambda 表达式



- 引用值



### 函数接口

![](images/函数接口.jfif)





## 二、流（Stream）

- 外部迭代 ====> 内部迭代（集合）
- 使用 Stream API 重构代码
- 链式操作



### 常用流操作

- 惰性求值方法 ===》返回值是 Stream

```java
/**
	- map：将一种类型的值转换成另一种类型
	
	- filter: 遍历数据，并检查其中的元素
	
	- flatMap：将多个 Stream 连接成一个 Stream
	
	- max/min: 查找Stream中的最大或最小元素，首先要考虑的是用什么作为排序的指标。
		-- Comparator.comparing(lambda)
*/
```

- 及早求值方法

```java
/**
	- collect(toList()): 生成一个列表
	
	- 通用模式 reduce：从一组值中生成一个值。
		-- 起点
		-- lambda 表达式：reducer，传入两个参数（Stream 的当前元素、操作）
*/
```



### 高阶函数

- 接收 / 返回一个函数的函数。
- 考虑 lambda 表达式的副作用：没有副作用的函数不会改变程序或外界的状态。





## 三、类库

- 默认方法/接口的静态方法
- 重载的工作原理
- 基本类型的使用

### 基本类型

- 对于需要大量数值运算的算法来说，装箱和拆箱的计算开销，以及装箱类型占用的额外内存，会明显减缓程序的运行速度。
- 为了减小这些性能开销，Stream类的某些方法对基本类型和装箱类型做了区分。**对基本类型做特殊处理的方法在命名上有明确的规范。**



### 重载解析

- 如果只有一个可能的目标类型，由**相应函数接口里的参数类型**推导得出；
- 如果有多个可能的目标类型，由**最具体的类型**推导得出； 
- 如果有多个可能的目标类型且最具体的类型不明确，则需**人为指定**类型。



### @FunctionalInterface

- 添加该注解，会强制 javac 检查一个接口是否符合函数接口的标准。
- 如果该注解添加给一个枚举类型、类或另一个注解，或者接口包含不止一个抽象方法，javac 就会报错。



### 默认方法

- 三定律：
  - **类胜于接口**。如果在继承链中有方法体或抽象的方法声明，那么就可以忽略接口中定义的方法。
  - **子类胜于父类。**如果一个接口继承了另一个接口，且两个接口都定义了一个默认方法，那么子类中定义的方法胜出。
  - **没有规则三**。如果上面两条规则不适用，子类要么需要**实现该方法**，要么将该方法**声明为抽象方法**。



### Stream 接口的静态方法

- Stream.of 是 Stream 接口的静态方法

```java
/**
	builder()
	
	empty()
	
	of(T t)
	
	of(T... values)
	
	iterate(final T seed, final UnaryOperator<T> f)
	
	generate(Supplier<T> s)
	
	concat(Stream<? extends T> a, Stream<? extends T> b)
*/
```





### Optional 对象

- 处理 null 值

- 常用 API

  ```java
  
  ```

  



## 四、高级集合类和收集器



### 方法引用

```java
/**
	a -> a.get() ===> A::get
*/
```

- 标准语法：ClassNama::methodName
- 所有 lambda 表达式都能转换成方法引用的形式。



### 元素顺序

- 有序集合：List
- 无序集合：set
- 在一个有序集合中创建一个流时，流中的元素就按出现顺序排列；如果集合本身就是无序的，由此生成的流也是无序的。
- 一些操作在有序的流上开销更大，调用 unordered 方法消除这种顺序就能解决该问题。大多数操作都是在有序流上效率更高，比如 ilter、map 和 reduce 等。



### 收集器

- 转换成其他集合：toList、toSet
- 定制集合：toCollection(TreeSet::new)
- 转换成值：maxBy/minBy/averagingInt/summingInt
  - Collectors.comparing(x)
- 数据分块：partitioningBy（分成 true/false）
  - 传入 lambda 表达式
- 数据分组：groupingBy
  - 传入 lambda 表达式
- 字符串连接：Collectors.joining(分隔符，前缀，后缀)
- 下游收集器：counting/mapping
- 可自定义收集器



## 五、数据并行化



### 并行化流操作

- parallelStream
  - 如果想从一个集合类创建一个流，调用 parallelStream 就能立即获得一个拥有并行能力的流。
- 性能：
  1. 数据大小：分解 ----> 并行化处理 ----> 结果合并
     - 只有数据足够大、每个数据处理管道花费的时间足够多时，并行化处理才有意义。
  2. 源数据结构：将不同的数据源分割相对容易，这里的开销影响了在管道中并行处理数据时到底能带来多少性能上的提升。
  3. 装箱：处理基本类型比处理装箱类型要快。
  4. CPU核数：运行时机器能使用多少核。
     - 同时运行的其他进程，或者线程关联性（强制线程在某些核或CPU上运行）会影响性能。
  5. 单元处理开销：花在流中每个元素身上的时间越长，并行操作带来的性能提升越明显。
- 在底层，并行流还是沿用了 fork/join 框架。
  - fork 递归式地分解问题，然后每段并行执行，最终由 oin 合并结果，返回最后的值。
- **如果能避开有状态，选用无状态操作，就能获得更好的并行性能。无状态操作包括 map、filter 和 flatMap，有状态操作包括 sorted、distinct 和 limit。**



### 并行化数组操作

- 数组上的并行化操作：
  - parallelPrefix：任意给定一个函数，计算数组的和
  - parallelSetAll：使用 Lambda 表达式更新数组元素
  - parallelSort：并行化对数组元素排序
- **改变了传入的数组，而没有创建一个新的数组。**



## 六、测试、调试和重构



### 重构候选项（局部的反模式或代码异味）

- 使用 lambda 重构代码
- 代码异味：
  - 进进出出、摇摇晃晃
  - 孤独的覆盖
  - 同样的东西写两遍（WET）



### Lambda 表达式的单元测试

1. 将Lambda表达式**放入一个方法测试**，这种方式要测那个方法，而不是Lambda表达式本身。
2. 使用方法引用。任何Lambda表达式都能被改写为普通方法，然后使用方法引用直接引用。



- 使用 Mockito 框架产生测试替身 ===》 代码即数据



### 惰性求值和调试



- 记录中间值：使用 peek 方法
  - 输出流中的值，同时避免了重复的流操作。
  - 只有最后调用及早求值方法，peek 方法才会生效。
- **在 peek 方法中加入断点，这样就能逐个调试流中的元素了**
  - peek 方法可以只包含一个空的方法体，只要能设置断点就可以。
  - 不允许在空的方法体重设置断点，将值简单地映射为其本身，这样就能设置断点。



## 七、设计和架构的原则

- 改变设计模式：在模式中使用 lambda 表达式
  - 命令者模式、策略模式、观察者模式、模板方法模式
- 使用 lambda 表达式的 SOLID 原则
  - 单一功能原则：高阶函数在方法级别实现
  - 开闭原则：
    - 高阶函数：对扩展开放、对修改闭合。
    - 使用不可变对象实现开闭原则。
      1. 观测不可变性（String）
      2. 实现不可变性（包含观测不可变性）
  - 依赖反转原则



## 八、并发程序

- 观察者模式
- 使用 Lambda 表达式表示行为，构建 API 来管理并发。



### CompletableFuture

- 别称：延迟对象/约定/ListenableFutures。
- CompletableFuture API 的技巧是注册 Lambda 表达式，并且把高阶函数链接起来。
- CompletableFuture 用例：
  - 在链的末端执行一些代码而不返回任何值（Consumer、Runnable）：**thenAccept、thenRun**
  - 转换 CompletableFuture 对象的值：**thenApply**
  - 在CompletableFuture对象出现异常时：使用 **exceptionally 方法**恢复，可以将一个函数注册到该方法，返回一个替代值。
  - 有一个 map，包含异常情况和正常情况：使用 **handle 方法**。
  - 找出 CompletableFuture 对象的问题：使用 **isDone 和 isCompleted-Exceptionally方法**辅助调查。



### 响应式编程 

- Stream 是为构建内存中集合的计算流程而设计的，而 RxJava 则是为了组合异步和基于事件的系统流程而设计的。
- Stream是为了计算最终结果，而RxJava在线程模型上则像CompletableFuture。
- 事件驱动和响应式编程何时使用：
  - **业务逻辑使用事件描述**
  - **同时处理大量 I/O 操作**