## 一、go 内存模型

### 先行发生（happens before）

- 当下面条件满足时，对变量 ***v*** 的读操作 ***r*** 是***被允许***看到对 ***v*** 的写操作 ***w*** 的：
  1.  r 不先行发生于 w
  2. 在 w 后 r 前没有对 v 的其他写操作
- 当下面条件满足时，***r 被保证***看到 ***w***：
  1. w 先行发生于 r
  2.  其他对共享变量v的写操作要么在w前，要么在r后。

### 同步 

- 初始化
  - **如果包 p 引入（import）包 q，那么q的 init 函数的结束*先行发生*于 p 的所有 init 函数开始** 
  - **main.main 函数的开始发生在所有 init 函数结束之后**
- 创建 goroutine
  - `go` 关键字开启新的 goroutine，**先行发生**于这个 goroutine 开始执行。
- 销毁 goroutine
  - gouroutine 的退出**并不会保证先行发生**于程序的任何事件。
- channel 通信
  - 带缓存：
    -  channel 的发送操作**先行发生**于对应的接收操作完成。
    - **对 channel 的关闭*先行发生*于接收到零值，因为 channel 已经被关闭了**。
    - **在容量为 C 的 channel 上的第 k 个接收*先行发生*于从这个 channel 上的第 k+C 次发送完成**。
      - 可以通过带缓冲的 channel 来实现计数信号量：channel 中的元素数量对应着活动的数量，channel 的容量表示同时活动的最大数量，发送元素获取信号量，接收元素释放信号量，这是限制并发的通常用法。
  - 无缓存：
    - **channel 的接收*先行发生*于发送完成。**
- 锁
  - **对任意的 sync.Mutex 或 sync.RWMutex 变量 l 和 n < m，n 次调用 l.Unlock() *先行发生*于 m 次 l.Lock() 返回**
  - **对于 sync.RWMutex 变量 l，任意的函数调用 l.RLock 满足第 n 次 l.RLock *后发生*于第n次调用 l.Unlock，对应的 l.RUnlock *先行发生*于第 n+1 次调用 l.Lock。**
- Once（多个goroutine提供了安全的初始化机制）
  - 从 Once.Do(f) 的单个调用 f() **先行发生**于任何调用 once.Do(f) 的返回。



## 二、协程（goroutine）和信道（channel）

### goroutine

- 基本概念：

  - **不要通过共享内存来通信，而通过通信来共享内存。**
  - **并发程序**：可能是并行的，也可能不是。
  - **竞态**：内存中的数据共享会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果。**不要使用全局变量或者共享内存。**
  - **协程**：
    - 使用少量的内存和资源
    - 协程可以运行在多个操作系统线程之间，也可以运行在线程之内
    - Go 的协程和通道支持**确定性的并发方式**
  - **两种并发方式**：
    - 确定性的（明确定义排序）
    - 非确定性的（加锁/互斥，从而未定义排序）
  - 信道（channel）
    - 数据通过信道：同一时间只有一个协程可以访问数据：所以不会出现数据竞争
- 常用方法：

  - runtime.Gosched()：让出处理器，允许运行其他协程；它不会使当前协程挂起，所以它会自动恢复执行。使用 `Gosched()` 可以使计算均匀分布，使通信不至于迟迟得不到响应。